<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-bagu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/27/bagu/" class="article-date">
  <time class="dt-published" datetime="2022-11-27T07:45:54.000Z" itemprop="datePublished">2022-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/27/bagu/">八股</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h3><h4 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h4><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221125164843.png" style="zoom:50%;" />

<ul>
<li>只要在代码头部添加了doctype声明，浏览器就会默认该页面为标准盒模型</li>
<li>如果不添加doctype声明，浏览器决定</li>
<li>也可以通过box-sizing属性设置：<code>box-sizing:content-box(标准盒模型) \ border-box(怪异盒模型)</code></li>
</ul>
<ol>
<li><p>标准盒模型(w3c盒子模型)：</p>
<p><code>一个盒子的总宽度= width + padding(左右) + border(左右)+ margin(左右)</code></p>
</li>
<li><p>怪异盒模型(ie盒子模型)：主要表现在IE内核的浏览器</p>
<p><code>一个盒子的总宽度= width + margin(左右)</code> （即width已经包含了padding和border值）</p>
</li>
</ol>
<h4 id="2-块元素和行内元素"><a href="#2-块元素和行内元素" class="headerlink" title="2. 块元素和行内元素"></a>2. 块元素和行内元素</h4><p><strong>区别</strong>：</p>
<ol>
<li><p>块级元素，宽度默认是它容器的100%,各占据一行，垂直方向排列；内联元素，都是同一行，水平方向排列</p>
</li>
<li><p>块级元素，能容纳其他块元素或者内联元素；内联元素，只能容纳文本或其他内联元素</p>
</li>
<li><p>块级元素中高度(height)，行高(line-height)以及外边距(margin)和内边距(padding)都可以控制；</p>
<p>行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</p>
</li>
</ol>
<p><strong>常见的块级元素</strong>：</p>
<ul>
<li>div</li>
<li>ul ,li 非排序列表</li>
<li>form - 交互表单</li>
<li>table - 表格</li>
<li>h1 -h6 标题</li>
<li>hr - 水平分隔线</li>
<li>p - 段落</li>
<li>dl -dt-dd - 定义列表</li>
<li>address - 地址</li>
<li>blockquote - 块引用</li>
<li>fieldset - form控制组</li>
</ul>
<p><strong>常见的内联元素</strong>：</p>
<ul>
<li>a - 锚点</li>
<li>select - 项目选择</li>
<li>span - 常用内联容器，定义文本内区块</li>
<li>strong - 粗体强调</li>
<li>img - 图片</li>
<li>input - 输入框</li>
<li>label - 表格标签</li>
<li>textarea - 多行文本输入框</li>
<li>br - 换行</li>
</ul>
<h4 id="3-html语义化标签"><a href="#3-html语义化标签" class="headerlink" title="3. html语义化标签"></a>3. html语义化标签</h4><p>语义化是指<strong>使用语义恰当的标签</strong>，使页面有<strong>良好的结构</strong>，页面<strong>元素有含义</strong>，能够<strong>让人和搜索引擎都容易理解</strong></p>
<p>比如：<code>header</code> <code>nav</code> <code>footer</code> <code>hgroup</code> <code>section</code> <code>article</code> <code>aside</code> <code>figure</code> <code>time</code> <code>address</code></p>
<h4 id="4-伪类和伪元素的区别"><a href="#4-伪类和伪元素的区别" class="headerlink" title="4. 伪类和伪元素的区别"></a>4. 伪类和伪元素的区别</h4><p>根本区别在于：它们是否抽象创造了新的元素</p>
<ul>
<li>伪类是通过在<strong>元素选择器上加入伪类</strong>改变元素状态：<ul>
<li>存在DOM文档中，逻辑上存在但在文档树中却无须标识的“幽灵”分类</li>
<li>伪类的效果可以通过添加实际的类来实现</li>
</ul>
</li>
<li>伪元素通过<strong>对元素的操作</strong>进行对元素的改变：<ul>
<li>不存在在DOM文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中</li>
<li>伪元素的效果可以通过添加实际的元素来实现</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>伪类只能使用“：”<br>而伪元素既可以使用“:”，也可以使用“::”</li>
<li>因为伪类是类似于添加类所以可以是多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾</li>
</ul>
<h4 id="5-css实现水平垂直居中"><a href="#5-css实现水平垂直居中" class="headerlink" title="5. css实现水平垂直居中"></a>5. css实现水平垂直居中</h4><ol>
<li><p>水平居中</p>
<ul>
<li><p>行内元素</p>
<p><code>text-align:center</code></p>
</li>
<li><p>块级元素</p>
<ol>
<li><p><code>display:flex</code>中的<code>align-self </code> + <code>flex-direction</code></p>
<p>无条件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="comment">/* width: 500px;</span></span><br><span class="line"><span class="comment">            height: 100px; */</span></span><br><span class="line">            <span class="comment">/* 父元素 display:flex */</span></span><br><span class="line">            <span class="attr">display</span>: flex;</span><br><span class="line">            flex-<span class="attr">direction</span>: column;<span class="comment">//flex-direction默认值是row(垂直居中使用)，另外一个是column</span></span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px;</span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">/* 子元素 align-self:center */</span></span><br><span class="line">            align-<span class="attr">self</span>: center;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>margin:auto + text-align</p>
<p>需要父元素长宽</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="comment">/* 父元素的width和height必须指定 */</span></span><br><span class="line">            <span class="attr">width</span>: 500px;</span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px;</span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">/* 通过margin+text-align实现水平居中 */</span></span><br><span class="line">            <span class="attr">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">            text-<span class="attr">align</span>: center;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>display:table-cell</code>+<code>margin-left</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="attr">width</span>: 200px;</span><br><span class="line">            <span class="attr">height</span>: 200px;</span><br><span class="line">            <span class="comment">/* 通过 display:table-cell 和 margin-left 实现水平居中 */</span></span><br><span class="line">            <span class="attr">display</span>: table-cell;</span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px;</span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">/* 让子元素左边与父元素的最左侧相距50%((200-100)/2) */</span></span><br><span class="line">            margin-<span class="attr">left</span>: 50px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>垂直居中</p>
<ul>
<li><p>行内元素</p>
<ol>
<li><code>verticle-align:middle</code></li>
<li>line-height：将子元素行高等于父元素height(适用于子元素为单行文本)</li>
</ol>
</li>
<li><p>块级元素</p>
<ol>
<li><p><code>display:flex</code>中的<code>align-self</code>+<code>flex-direction</code></p>
<p>无条件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="comment">/* width: 500px;</span></span><br><span class="line"><span class="comment">            height: 100px; */</span></span><br><span class="line">            <span class="comment">/* 父元素 display:flex */</span></span><br><span class="line">            <span class="attr">display</span>: flex;</span><br><span class="line">            <span class="comment">//flex-direction: row;</span></span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px;</span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">/* 子元素 align-self:center */</span></span><br><span class="line">            align-<span class="attr">self</span>: center;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>margin:auto+绝对定位（水平垂直居中）</p>
<p>需要父元素长宽</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="attr">width</span>: 500px;</span><br><span class="line">            <span class="attr">height</span>: 500px;</span><br><span class="line">            <span class="comment">//父元素相对</span></span><br><span class="line">            <span class="attr">position</span>: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px; </span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">//单独使用仅会水平居中</span></span><br><span class="line">            <span class="attr">margin</span>: auto;  </span><br><span class="line">            <span class="comment">//绝对居中</span></span><br><span class="line">            <span class="attr">position</span>: absolute;  </span><br><span class="line">            <span class="comment">//上下左右设置为零</span></span><br><span class="line">            <span class="attr">top</span>: <span class="number">0</span>;  </span><br><span class="line">            <span class="attr">left</span>: <span class="number">0</span>;  </span><br><span class="line">            <span class="attr">right</span>: <span class="number">0</span>;  </span><br><span class="line">            <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>display:table(-cell)</code>+<code>margin-left</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="attr">width</span>: 200px;</span><br><span class="line">            <span class="attr">height</span>: 200px;</span><br><span class="line">            <span class="comment">/* 通过 display:table-cell 和 margin-left 实现水平居中 */</span></span><br><span class="line">            <span class="attr">display</span>: table;</span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px;</span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">/* 让子元素左边与父元素的最左侧相距50%((200-100)/2) */</span></span><br><span class="line">            <span class="attr">display</span>: table-cell;</span><br><span class="line">            vertical-<span class="attr">align</span>: middle;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>水平垂直居中：</p>
<ul>
<li><p>行内元素</p>
<ol>
<li><p>利用水平对齐<code>text-align</code>和行高<code>line-height</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">div5</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: #eee;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  margin-<span class="attr">top</span>: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">div5</span> .<span class="property">center</span> &#123;</span><br><span class="line">  <span class="comment">//水平对齐</span></span><br><span class="line">  text-<span class="attr">align</span>: center;</span><br><span class="line">  <span class="comment">//行高等于父元素高度</span></span><br><span class="line">  line-<span class="attr">height</span>: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>块级元素</p>
<ol>
<li><p><code>flex</code>布局</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="attr">height</span>: 600px;</span><br><span class="line">            <span class="comment">//布局</span></span><br><span class="line">            <span class="attr">display</span>: flex;</span><br><span class="line">            <span class="comment">//水平</span></span><br><span class="line">            justify-<span class="attr">content</span>: center;</span><br><span class="line">            <span class="comment">//垂直</span></span><br><span class="line">            align-<span class="attr">items</span>: center;</span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px; </span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>margin:auto</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aqua;</span><br><span class="line">            <span class="attr">width</span>: 500px;</span><br><span class="line">            <span class="attr">height</span>: 500px;</span><br><span class="line">            <span class="comment">//父元素相对</span></span><br><span class="line">            <span class="attr">position</span>: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        #son&#123;</span><br><span class="line">            background-<span class="attr">color</span>: aquamarine;</span><br><span class="line">            <span class="attr">width</span>: 100px; </span><br><span class="line">            <span class="attr">height</span>: 100px;</span><br><span class="line">            <span class="comment">//单独使用仅会水平居中</span></span><br><span class="line">            <span class="attr">margin</span>: auto;  </span><br><span class="line">            <span class="comment">//绝对</span></span><br><span class="line">            <span class="attr">position</span>: absolute;  </span><br><span class="line">            <span class="comment">//上下左右设置为零</span></span><br><span class="line">            <span class="attr">top</span>: <span class="number">0</span>;  </span><br><span class="line">            <span class="attr">left</span>: <span class="number">0</span>;  </span><br><span class="line">            <span class="attr">right</span>: <span class="number">0</span>;  </span><br><span class="line">            <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>布局<code>grid</code></p>
<ul>
<li>在子元素设置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">div6</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: #eee;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  margin-<span class="attr">top</span>: 20px;</span><br><span class="line">  <span class="comment">//设置grid布局</span></span><br><span class="line">  <span class="attr">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">div6</span> .<span class="property">center</span> &#123;</span><br><span class="line">  <span class="comment">//垂直</span></span><br><span class="line">  align-<span class="attr">self</span>: center;</span><br><span class="line">  <span class="comment">//水平</span></span><br><span class="line">  justify-<span class="attr">self</span>: center;</span><br><span class="line">  <span class="comment">/* margin: auto; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>父元素设置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">div6</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: #eee;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 200px;</span><br><span class="line">  margin-<span class="attr">top</span>: 20px;</span><br><span class="line">  <span class="comment">//设置布局</span></span><br><span class="line">  <span class="attr">display</span>: grid;</span><br><span class="line">  <span class="comment">//垂直和水平</span></span><br><span class="line">  align-<span class="attr">items</span>: center;</span><br><span class="line">  justify-<span class="attr">items</span>: center;</span><br><span class="line">  <span class="comment">//另一种形式</span></span><br><span class="line">  <span class="comment">/* align-content: center;</span></span><br><span class="line"><span class="comment">  justify-content: center; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="6-css常见选择器"><a href="#6-css常见选择器" class="headerlink" title="6. css常见选择器"></a>6. css常见选择器</h4><ul>
<li><p>标签名选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签名 &#123;</span><br><span class="line">	属性<span class="number">1</span>:属性值<span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">	属性<span class="number">1.</span>属性值<span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>id选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;</span><br><span class="line">	属性<span class="number">1</span>:属性值<span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通配符选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	属性名<span class="number">1</span>: 属性名<span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>复合选择器</p>
<ul>
<li><p>后代&#x2F;包含选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	元素<span class="number">1</span> 元素<span class="number">2</span> &#123; 样式声明 &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="comment">//元素2只要包含在元素1里面即可，无论是儿子还是孙子</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子选择器：只能选择某元素的最近一级的子元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素<span class="number">1</span>&gt;元素<span class="number">2</span> &#123;样式声明&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并集选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签<span class="number">1</span>,标签<span class="number">2</span> &#123;样式声明&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪类选择器</p>
</li>
</ul>
<h4 id="7-优先级算法"><a href="#7-优先级算法" class="headerlink" title="7. 优先级算法"></a>7. 优先级算法</h4><ol>
<li><p>首先，判断属性声明是否有<strong>权重</strong>，也就是是否在声明后面加上了<code>!important</code>。</p>
<p>一条声明如果加上权重，那么他的优先级就是最高的，前提是它之后不再出现相同权重的声明。</p>
</li>
<li><p>如果<strong>权重相同</strong>，我们则需要去比较匹配规则的特殊性</p>
<p>一条匹配规则由多个选择器构成，，分为四个等级，特殊性累加但不会进位</p>
<ul>
<li><p>行内样式，为<code>1 0 0 0</code></p>
</li>
<li><p><code>id</code>选择器，为<code>0 1 0 0 </code></p>
</li>
<li><p>类选择器，伪类选择器，属性选择器为：<code>0 0 1 0</code></p>
</li>
<li><p>元素选择器和伪元素选择器：<code>0 0 0 1</code></p>
<p>从左往右比较，eg：特殊性值为<code>1000</code>的规则优先级就要比特殊性值为<code>0999</code>的规则高</p>
</li>
</ul>
</li>
<li><p>如果特殊性值相等，根据他们引用的顺序，<strong>后出现</strong>的规则的优先级<strong>最高</strong></p>
</li>
</ol>
<h4 id="8-px-em-和-rem的区别"><a href="#8-px-em-和-rem的区别" class="headerlink" title="8. px em 和 rem的区别"></a>8. px em 和 rem的区别</h4><ul>
<li><code>px</code>是固定的<strong>像素</strong>，一旦设置了就无法因为适应页面大小而改变</li>
<li><code>em</code>和<code>rem</code>相对于<code>px</code>更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局</li>
<li><code>em</code>是<strong>相对于其父元素</strong>来设置字体大小的，一般都是以<code>font-size</code>为基准。这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小</li>
<li><code>Rem</code>是<strong>相对于根元素</strong>，这样就意味着，我们只需要在根元素确定一个参考值</li>
</ul>
<h4 id="9-Flex布局"><a href="#9-Flex布局" class="headerlink" title="9. Flex布局"></a>9. Flex布局</h4><p>采用 Flex 布局的元素，称为 Flex 容器，所有子元素自动成为容器成员，称为 Flex 项目</p>
<p>容器有六个属性：</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h4 id="10-浮动塌陷的解决方法"><a href="#10-浮动塌陷的解决方法" class="headerlink" title="10. 浮动塌陷的解决方法"></a>10. 浮动塌陷的解决方法</h4><ol>
<li><p>在浮动元素后面添加元素，并为其设置clear属性</p>
</li>
<li><p>after伪类(推荐)</p>
<p>通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，效果与<code>1</code>相同且不会在页面中添加多余元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">clearfix</span>::after&#123;</span><br><span class="line">    <span class="attr">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attr">display</span>: block;</span><br><span class="line">    <span class="attr">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给父元素设置 overflow：hidden</p>
<p>但是因为触发了BFC块级化格式上下文 就会按照bfc的规则渲染画面 bfc规则为浮动的元素也参与计算高度</p>
<p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221126221500.png"></p>
</li>
</ol>
<h4 id="11-position"><a href="#11-position" class="headerlink" title="11. position"></a>11. position</h4><p>规定元素的定位类型</p>
<ul>
<li><p><code>absolute</code>(绝对定位)：元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 <code>&lt;html&gt;</code></p>
</li>
<li><p><code>fixed</code>(固定定位)：相对于浏览器窗口进行定位</p>
</li>
<li><p><code>relative</code>(相对定位)：相对于其正常位置进行定位，不影响其他元素的偏移</p>
</li>
<li><p><code>sticky</code>(粘性定位)：跨越特定阈值前为相对定位，之后为固定定位</p>
<p>eg：<img src="https://raw.githubusercontent.com/LVZJself/image/main/20221126222907.png"></p>
<ul>
<li>须指定 <code>top</code> 、 <code>right</code> 、 <code>bottom</code> 、 <code>left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高</li>
</ul>
</li>
<li><p><code>static</code>(静态定位)：默认定位方式；始终根据页面的正常流进行定位</p>
</li>
<li><p><code>inherit</code>：继承父元素的 <code>position</code> 值</p>
</li>
</ul>
<h4 id="12-BFC、IFC"><a href="#12-BFC、IFC" class="headerlink" title="12. BFC、IFC"></a>12. BFC、IFC</h4><ul>
<li><p>BFC(Block Formatting Contexts)：块级格式化上下文，是一个决定如何渲染元素的容器</p>
<ul>
<li><p>触发条件：</p>
<ul>
<li>根元素</li>
<li><code>flloat</code>的值不是<code>none</code></li>
<li><code>position</code>的值不是<code>static</code>或<code>relative</code></li>
<li><code>display</code>的值是<code>inline-block、inline-flex、flex、flow-root、table-caption、table-cell</code></li>
<li><code>overflow</code>的值不是<code>visible</code></li>
</ul>
</li>
<li><p>渲染规则：</p>
<ul>
<li>内部的块级元素会在垂直方向一个接一个的放置</li>
<li>块级元素垂直方向的距离由margin决定，属于同一个BFC的两个相邻块级元素的margin会发生重叠</li>
<li>对于从左往右的格式化，每个元素（块级元素与行内元素）的左边缘，与包含块的左边缘相接触，(对于从右往左的格式化则相反)。即使包含块中的元素存在浮动也是如此，除非其中元素再生成一个BFC。</li>
<li>BFC的区域不会与浮动元素重叠<br>这点是BFC最重要的一点渲染规则，可以用这个规则解决很多布局的问题。</li>
<li>BFC是一个隔离的独立容器，容器里面的子元素和外面的元素互不影响。</li>
<li>计算BFC容器的高度时，浮动元素也参与计算。<br>这个规则，可以用来解决内部元素浮动，导致父级元素的高度坍塌问题</li>
</ul>
</li>
<li><p>应用：</p>
<ul>
<li><p>清除浮动<br>根据BFC的渲染规则第6点（计算BFC容器的高度时，浮动元素也参与计算）来清除浮动，解决高度坍塌的问题。</p>
</li>
<li><p>解决上下margin边距重叠问题<br>利用BFC渲染规则第2点（属于同一个BFC的两个相邻块级元素的margin会发生重叠），那么不属于同一个BFC的两个相邻块级元素的margin就不会发生重叠。</p>
</li>
<li><p>实现自适应两栏布局：</p>
<p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221126225314.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .<span class="property">main</span>&#123;</span><br><span class="line">        <span class="attr">background</span>: red;</span><br><span class="line">        <span class="attr">height</span>:500px;</span><br><span class="line">        <span class="attr">overflow</span>:auto</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="property">sider</span> &#123;</span><br><span class="line">        <span class="attr">float</span>: left;</span><br><span class="line">        <span class="attr">width</span>: <span class="number">20</span>%;</span><br><span class="line">        <span class="attr">height</span>:300px;</span><br><span class="line">        <span class="attr">background</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sider&quot;</span>&gt;</span>我是侧边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>我是主体内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>IFC(Inline Formatting Contexts)：内联格式化上下文</p>
<ul>
<li><p>触发条件：块级元素内仅包含内联元素</p>
<p>注意：当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个IFC</p>
</li>
<li><p>渲染规则：</p>
<ul>
<li>子元素水平方向横向排列，并且垂直方向起点为元素顶部。</li>
<li>子元素只会计算横向样式空间，【padding、border、margin】，垂直方向样式空间不会被计算，【padding、border、margin】。</li>
<li>在垂直方向上，子元素可以不同形式对齐（vertical-align）</li>
<li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和与其中的浮动元素来决定。</li>
<li>IFC中的“line box”一般左右边贴紧其包含块，但float元素会优先排列。</li>
<li>IFC中的“line box”高度由 CSS 行高计算规则来确定，同个IFC下的多个line box高度可能会不同。</li>
<li>当 inline-level boxes的总宽度少于包含它们的line box时，其水平渲染规则由 text-align 属性值来决定。</li>
<li>当一个“inline box”超过父元素的宽度时，它会被分割成多个boxes，这些 boxes 分布在多个“line box”中。如果子元素未设置强制换行的情况下，“inline box”将不可被分割，将会溢出父元素</li>
</ul>
</li>
<li><p>应用：</p>
<ul>
<li>水平居中，当一个块要在当前环境水平居中，设置<code>display:inline-block</code>,会在外层生成一个IFC，通过设置<code>text-align:center</code>既可使其居中</li>
<li>垂直居中，创建一个IFC，用其中一个元素撑开高度，然后设置其<code>vertical-align:middle</code>，其他行内元素则可以在此父元素下垂直居中</li>
</ul>
</li>
</ul>
</li>
<li><p>FFC(Flex formatting contexts)：弹性盒模型</p>
<ul>
<li>触发条件：父级元素设置<code>display:flex</code>或者<code>display:inline-flex</code></li>
</ul>
</li>
</ul>
<h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="1-上传"><a href="#1-上传" class="headerlink" title="1. 上传"></a>1. 上传</h4><ul>
<li>传统开发上传(前后端混合)：将表单中文件传给后端，后端做上传</li>
<li>前后端分离：将<code>file</code>数据添加到<code>FormData</code>对象上，利用ajax上传</li>
</ul>
<ol>
<li><p>单文件上传</p>
<p>表单元素上传：<code>&lt;input type=&quot;file&quot; id=&quot;file-uploader&quot;&gt;</code></p>
<p>上传成功后获取File对象</p>
<ul>
<li><p>首先，通过<code>id</code>获取文件上传的实例</p>
<p><code>const fileUploader = document.getElementById(&#39;file-uploader&#39;);</code></p>
</li>
<li><p>然后添加一个<code>change</code> 事件侦听器，以在上传完成后读取文件对象；我们从<code>event.target.files</code>属性获取上传的文件信息</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileUploader.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> files = event.<span class="property">target</span>.<span class="property">files</span>;</span><br><span class="line"> <span class="comment">//console.log(&#x27;files&#x27;, files);//具有文件所有信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>多文件：如果我们想上传多个文件，需要在标签上添加 <code>multiple</code> 属性</p>
<p><code>&lt;input type=&quot;file&quot; id=&quot;file-uploader&quot; multiple /&gt;</code></p>
</li>
<li><p>显示文件预览内容</p>
<p>可以使用<code>FileReader</code>对象将文件转换为二进制字符串。 然后添加<code>load</code> 事件侦听器，以在成功上传文件时获取二进制字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileReader 实例</span></span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">fileUploader.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> files = event.<span class="property">target</span>.<span class="property">files</span>;</span><br><span class="line">  <span class="keyword">const</span> file = files[<span class="number">0</span>];</span><br><span class="line">  reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">  reader.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    imageGrid.<span class="title function_">appendChild</span>(img);</span><br><span class="line">    img.<span class="property">src</span> = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    img.<span class="property">alt</span> = file.<span class="property">name</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>模拟上传进度</p>
<p><code>FileReader</code>中的<code>process</code>事件表示上传进度</p>
</li>
<li><p>拖拽上传</p>
<ul>
<li><p>首先，创建一个拖放区域和一个可选的区域来显示上传的文件内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Drag &amp; Drop an Image<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drop-zone&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        DROP HERE</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Your image to appear here..</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过它们各自的ID获取<code>dropzone</code>和<code>content</code> 区域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dropZone = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;drop-zone&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一个<code>dragover</code> 事件处理程序，以显示将要复制的内容的效果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dropZone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  event.<span class="property">dataTransfer</span>.<span class="property">dropEffect</span> = <span class="string">&#x27;copy&#x27;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    dropEffect:设置或返回拖放目标上允许发生的拖放行为。如果此处设置的拖放行为不再effectAllowed属性设置的多种拖放行为之内，拖放操作将会失败。该属性值只允许为“null”、“copy”、“link”和“move”四值之一</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，我们需要一个<code>drop</code>事件监听器来处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dropZone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Get the files</span></span><br><span class="line">  <span class="keyword">const</span> files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="2-压缩上传图片"><a href="#2-压缩上传图片" class="headerlink" title="2. 压缩上传图片"></a>2. 压缩上传图片</h4><p>简版：思路：</p>
<ol>
<li><p>input 读取到 image&#x2F;file 创建一个FileReader 使用 FileReader 将其转换为 base64 编码</p>
</li>
<li><p>document.createElement(“canvas”) 创建canvas</p>
</li>
<li><p>new Image 创建img元素 使img的src指向FileReader转换的base64</p>
</li>
<li><p>ctx.drawImage(img,0,0, canvas.width, canvas.height) 将img画到canvas上</p>
</li>
<li><p>canvas.toDataURL(file.type, quality) 将canvas转换为图片base64格式</p>
<p>最后返回的都是base64格式数据，如需file格式，需进行处理</p>
<p>将 base64 转为 blod 再转为 file</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compressPic</span>(<span class="params">file, quality</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reads = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reads.<span class="title function_">readAsDataURL</span>(file)</span><br><span class="line">    reads.<span class="property">onload</span> = (&#123; <span class="attr">target</span>: &#123; <span class="attr">result</span>: src &#125;&#125;) &#123;</span><br><span class="line">         <span class="comment">// 这里quality的范围是（0-1）</span></span><br><span class="line">         <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">         <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">         <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">         img.<span class="property">src</span> = src;</span><br><span class="line">         img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              <span class="keyword">let</span> width = img.<span class="property">width</span>;</span><br><span class="line">              canvas.<span class="property">width</span> = width;</span><br><span class="line">              canvas.<span class="property">height</span> = width * (img.<span class="property">height</span> / img.<span class="property">width</span>);</span><br><span class="line">              ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">              <span class="comment">// 转换成base64格式 quality为图片压缩质量 0-1之间  值越小压缩的越大 图片质量越差</span></span><br><span class="line">              <span class="keyword">let</span> data = canvas.<span class="title function_">toDataURL</span>(file.<span class="property">type</span>, quality);</span><br><span class="line">              <span class="keyword">return</span> data</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些情况下出现问题，压缩后占内存更大，可使用以下方法</p>
<p><strong>二分法</strong>：quality取0.5，压缩后比较指定体积和压缩体积；重复进行3-4次</p>
<h4 id="3-前后端交互数据格式"><a href="#3-前后端交互数据格式" class="headerlink" title="3. 前后端交互数据格式"></a>3. 前后端交互数据格式</h4><ol>
<li><strong>application&#x2F;json</strong><ul>
<li>获取到字符串</li>
</ul>
</li>
<li><strong>multipart&#x2F;form-data</strong><ul>
<li>基于post方法</li>
<li>一般用来上传文件</li>
<li>获取到数字</li>
</ul>
</li>
</ol>
<h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4. 原型链"></a>4. 原型链</h4><p>实例对象与原型的连接组成的链（原型对象本身对于对象实例来说也是对象，它也有自己的原型，所以形成了一条原型链）</p>
<p><code>prototype</code>对于<strong>构造函数</strong>来说它是<strong>属性</strong>，对于<strong>对象的实例</strong>来说它是一个<strong>原型对象</strong></p>
<ul>
<li><p>每个对象(<strong>函数也是对象</strong>)都有一个<code>proto</code>属性，指向原型对象</p>
</li>
<li><p><code>prototype</code><strong>属性</strong>，它是<strong>函数所独有的</strong>，它是从<strong>一个函数指向一个对象</strong>，也就是这个函数所创建的实例的原型对象</p>
</li>
<li><p>每个<strong>原型对象</strong>有一个<code>constructor</code>属性，指向创建对象的<strong>函数</strong>本身</p>
</li>
<li><p>原型对象的作用就是定义 所有对象实例所<strong>共享</strong>的属性和方法</p>
</li>
<li><p>作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个 方法或属性，那么Javascript引擎将会访问这个对象的<code>proto</code>属性所指向上一个对象(即该对象的原型对象)，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象 的<code>proto</code>属性指向的对象进行向上查找，直到这个链表结束</p>
</li>
<li><p>所有一切的原型顶端，都是<code>Object.prototype</code>,即<code>Object</code>构造函数的<code>prototype</code>属性指向的那个对象</p>
</li>
<li><p><code>instanceof</code>是判断 <strong>实例对象</strong>的<code>proto</code> 和 <strong>生成该实例的构造函数</strong>的<code>prototype</code> 是不是<strong>引用同一个地址</strong>(即是否指向同一个原型对象)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> A); <span class="comment">//true 表示指定对象是否为某个构造函数的实例</span></span><br></pre></td></tr></table></figure>

<p>因为<code>instanceof</code>对整个原型链上的对象都有效，所以<strong>同一个实例对象</strong>，可能会对<strong>多个构造函数</strong>都返回<code>true</code>。只能用于复杂数据类型（数组、对象等），不能用于简单数据类型（布尔值、数字、字符串等）</p>
</li>
</ul>
<h4 id="5-Js继承"><a href="#5-Js继承" class="headerlink" title="5. Js继承"></a>5. Js继承</h4><p>目的：重复利用另外一个对象的属性和方法</p>
<ol>
<li><p>原型链继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Woman</span>(<span class="params"></span>)&#123; &#125;</span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>= <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;haixia&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> womanObj = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：简单易于实现，父类的新增的实例与属性子类都能访问</li>
<li>缺点：<ul>
<li>无法实现<strong>多继承</strong></li>
<li>创建子类实例时，不能向父类构造函数中<strong>传参数</strong></li>
<li>对象实例共享所有继承的属性和方法</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Box</span>(<span class="params">name</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Box</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Desk</span>(<span class="params">name</span>)&#123;</span><br><span class="line"> <span class="title class_">Box</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 对象冒充，对象冒充只能继承构造里的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> desk = <span class="keyword">new</span> <span class="title class_">Desk</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(desk.<span class="property">name</span>)   <span class="comment">// --&gt; ccc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(desk.<span class="property">age</span>)    <span class="comment">// --&gt; undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：<ul>
<li>解决了<strong>原型链实现继承</strong>的<strong>不能传参</strong>的问题</li>
<li>解决了<strong>父类的原型共享</strong>的问题</li>
<li>实现<strong>多继承</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>方法都在构造函数中定义，因此无法实现函数复用</li>
<li>不能继承<strong>原型</strong>属性&#x2F;方法，只能继承<strong>父类</strong>的实例属性和方法</li>
</ul>
</li>
</ul>
</li>
<li><p>原型式继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;   <span class="comment">//传递一个字面量函数</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;     <span class="comment">//创建一个构造函数</span></span><br><span class="line"> F.<span class="property"><span class="keyword">prototype</span></span> = o;    <span class="comment">//把字面量函数赋值给构造函数的原型</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()     <span class="comment">//最终返回出实例化的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：修改作为原型的变量<code>o</code>，修改会被共享</p>
</li>
<li><p>寄生式继承（与原型式类似）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">obj</span>(<span class="params">o</span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">F</span> ()&#123;&#125;</span><br><span class="line"> F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> clone = <span class="title function_">obj</span>(o)   <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line"> clone.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;   <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> clone   <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;ccc&#x27;</span>,</span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">create</span>(person)</span><br><span class="line">anotherPerson.<span class="title function_">sayName</span>()   <span class="comment">// --&gt; hi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：不需要单独创建构造函数</li>
<li>缺点：给对象添加函数会导致函数难以重用</li>
</ul>
</li>
<li><p>class继承</p>
</li>
</ol>
<h4 id="6-JS中的数据类型"><a href="#6-JS中的数据类型" class="headerlink" title="6. JS中的数据类型"></a>6. JS中的数据类型</h4><ul>
<li>基础数据类型(原始)：<ul>
<li>number</li>
<li>boolean</li>
<li>string</li>
<li>null</li>
<li>undefined</li>
<li>symbol（es6）</li>
<li>bigint(谷歌67)</li>
</ul>
</li>
<li>引用数据类型(对象)：<ul>
<li>object</li>
</ul>
</li>
</ul>
<h4 id="7-判断数据类型"><a href="#7-判断数据类型" class="headerlink" title="7. 判断数据类型"></a>7. 判断数据类型</h4><ol>
<li><p><code>Object.prototype.toString()</code></p>
<p>注意：Object原型对象上的toString方法才能判断，其他原型对象上的不能判断，如：Array重写了toString不能判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(要判断类型的数据);</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(要判断类型的数据);</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">bind</span>(要判断类型的数据)();</span><br></pre></td></tr></table></figure>

<p>缺点：无法判断<strong>自定义构造函数</strong>创造出来的实例</p>
<p>eg：<img src="https://raw.githubusercontent.com/LVZJself/image/main/20221127221206.png"></p>
</li>
<li><p><code>constructor属性</code></p>
<p>用来判断某个实例对象是不是这个构造函数创建出来的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Anamil</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ana1 = <span class="keyword">new</span> <span class="title class_">Anamil</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(ana1.<span class="property">constructor</span> == <span class="title class_">Anamil</span>)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(ana1.<span class="property">constructor</span> == <span class="title class_">Object</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code></p>
<p>用来判断B在不在A的原型链上</p>
</li>
<li><p><code> typeof</code></p>
<p>注意：<code>typeof</code>运算符识别<code>null</code>的时候会返回<code>Object</code></p>
</li>
</ol>
<h4 id="8-判断是否为数组"><a href="#8-判断是否为数组" class="headerlink" title="8. 判断是否为数组"></a>8. 判断是否为数组</h4><ol>
<li><p><code>isArray</code> 方法</p>
<p><code>Array.isArray(arr); // true</code></p>
</li>
<li><p>对象原型：判断是否有相同原型链顶端</p>
<p><code>arr.__proto__ === Array.prototype; // true</code></p>
</li>
<li><p><code>instance</code>：检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p>
<p><code>arr instanceof Array; // true</code></p>
</li>
<li><p>Object.prototype.toString.call()：所有原始数据类型都能通过该方法判断，具有通用性</p>
</li>
</ol>
<h4 id="9-Null-和-undefined-的区别"><a href="#9-Null-和-undefined-的区别" class="headerlink" title="9. Null 和 undefined 的区别"></a>9. Null 和 undefined 的区别</h4><p><strong>未声明变量</strong>：未使用var、let、const声明变量，就为一个变量赋值</p>
<ul>
<li>全局作用域（严格模式下报错）</li>
</ul>
<p><strong>undefined</strong>：一个变量已经声明但没有赋值&#x2F;未被声明&#x2F;没有传入实参的形参变量&#x2F;函数什么都不返回默认返回</p>
<ul>
<li>使用严格相等（&#x3D;&#x3D;&#x3D;）检查，使用非严格相等（&#x3D;&#x3D;）与null判断时，返回为true</li>
</ul>
<p><strong>null</strong>：只能被显式赋值给变量</p>
<ul>
<li>检查同undefined</li>
</ul>
<h4 id="10-call-bind-apply的区别"><a href="#10-call-bind-apply的区别" class="headerlink" title="10. call bind apply的区别"></a>10. call bind apply的区别</h4><ul>
<li><p>相同点：</p>
<ul>
<li>第一个参数都是<code>this</code>的指向，且当第一个参数为<code>null或undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</li>
<li>都改变<code>this</code>指向</li>
</ul>
</li>
<li><p><code>apply</code></p>
<ul>
<li>第二个参数是函数接受的参数，<strong>以数组的形式传入</strong></li>
<li><strong>立即</strong>执行</li>
<li>仅改变一次<code>this</code>指向</li>
</ul>
</li>
<li><p><code>call</code></p>
<ul>
<li>后面传入的是一个<strong>参数列表</strong>（注意和<code>apply</code>传参的区别），依次传参</li>
<li><strong>立即</strong>执行</li>
<li>仅改变一次<code>this</code>指向</li>
</ul>
</li>
<li><p><code>bind</code></p>
<ul>
<li>依次传参</li>
<li>异步代码，不会立即执行，而是返回一个新的函数</li>
<li>绑定在返回的新函数</li>
</ul>
</li>
</ul>
<h4 id="11-防抖节流"><a href="#11-防抖节流" class="headerlink" title="11. 防抖节流"></a>11. 防抖节流</h4><ul>
<li><p>防抖：n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">		timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">			fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">		&#125;, delay)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节流：n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> valid = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(valid) &#123;</span><br><span class="line">			<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">				fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">				valid = <span class="literal">true</span>;</span><br><span class="line">			&#125;, delay)</span><br><span class="line">			valid = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相同点：</p>
<ul>
<li>为了阻止操作高频触发，从而浪费性能</li>
<li>都可以通过使用 <code>setTimeout</code> 实现</li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li><p>防抖：在一段连续操作<strong>结束后</strong>，处理回调，利用<code>clearTimeout</code>和 <code>setTimeout</code>实现</p>
<p>节流：在一段连续操作<strong>中</strong>，每一段时间只执行一次，频率较高的事件中使用来提高性能</p>
</li>
<li><p>防抖：关注一定时间连续触发的事件，只在最后执行一次</p>
<p>节流：一段时间内只执行一次</p>
</li>
</ul>
</li>
<li><p>应用场景： </p>
<p>防抖：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染</li>
</ul>
<p>节流：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
</li>
</ul>
<h4 id="12-深-x2F-浅拷贝"><a href="#12-深-x2F-浅拷贝" class="headerlink" title="12. 深&#x2F;浅拷贝"></a>12. 深&#x2F;浅拷贝</h4><p><strong>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型</strong></p>
<ul>
<li><p><strong>浅拷贝</strong>只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享<strong>同一块内存</strong></p>
<p>实现：</p>
<ul>
<li><p><code>Object.assign() //将第二个参数及以后的参数合并到第一个对象里</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;kaiqin&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;&#125;;</span><br><span class="line">     <span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj);</span><br><span class="line">     obj1.<span class="property">a</span>.<span class="property">name</span>=<span class="string">&quot;wang&quot;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)<span class="comment">//&#123; a: &#123; name: &#x27;wang&#x27;, age: 19 &#125; &#125;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)<span class="comment">//&#123; a: &#123; name: &#x27;wang&#x27;, age: 19 &#125; &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>for in //对象必须是多层的状态下才能实现浅拷贝</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">1</span>,<span class="attr">c</span>:<span class="number">2</span> &#125; &#125; ;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//多层</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            newObj[key] = obj[key];</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多层浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OBJ1</span> = <span class="title function_">copy</span>(obj1);</span><br><span class="line"><span class="title class_">OBJ1</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">OBJ1</span>)<span class="comment">//&#123; a: &#123;b:0,c:2 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)<span class="comment">//&#123; a: &#123;b:0,c:2 &#125; &#125;</span></span><br><span class="line"><span class="comment">//单层深拷贝</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OBJ2</span> = <span class="title function_">copy</span>(obj2);</span><br><span class="line"><span class="title class_">OBJ2</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">OBJ2</span>)<span class="comment">//&#123; a: &#123;b:0,c:2 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)<span class="comment">//&#123; a: &#123;b:1,c:2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$.extend()</code></p>
<ul>
<li>1、布尔值 如果填true的情况下是深考贝 什么也不写就是浅拷贝</li>
<li>2、目标对象</li>
<li>3……后面所有的对象 都是需要合并的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;kaiqin&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;wang&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj2 = $.<span class="title function_">extend</span>(&#123;&#125;,obj,obj1)</span><br><span class="line">obj2.<span class="property">a</span>.<span class="property">name</span>=<span class="string">&quot;zhang&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>深拷贝</strong>会另外创造一个一模一样的对象，新对象跟原对象<strong>不共享内存</strong>，修改新对象不会改到原对象</p>
<ul>
<li><p>对象是单层的情况下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj);</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1,obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$.extend() //true的情况下是深拷贝</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;kaiqin&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;wang&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = $.<span class="title function_">extend</span>(<span class="literal">true</span>,&#123;&#125;,obj,obj1);</span><br><span class="line">obj2.<span class="property">a</span>.<span class="property">name</span>=<span class="string">&quot;zhang&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>JSON.parse、JSON.stringfiy //不能拷贝函数，但用在拷贝数据库数据时，不影响。因为数据库没有函数。所以推荐使用</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">&quot;wang&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));   <span class="comment">//此时地址发生了改变。</span></span><br><span class="line">obj2.<span class="property">b</span>.<span class="property">name</span> = <span class="string">&quot;kaiqin&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1,obj2)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="13-let-x2F-var-x2F-const"><a href="#13-let-x2F-var-x2F-const" class="headerlink" title="13. let&#x2F;var&#x2F;const"></a>13. let&#x2F;var&#x2F;const</h4><ol>
<li><p><code>var</code>为函数作用域，<code>let/const</code>为块级作用域</p>
</li>
<li><p><code>var</code>可以变量提升</p>
</li>
<li><p><code>var</code>：可重复声明，值可变</p>
<p><code>let</code>：同一块级作用域下，<code>let</code>只能声明一次</p>
<p><code>const</code>：声明时必须赋值，且不允许改变</p>
</li>
<li><p><code>var</code>在全局作用域声明时会成为<code>windows</code>对象的属性</p>
<p><code>let</code>不会，但对应变量会在生命周期内存续，访问时为<code>undefined</code></p>
</li>
</ol>
<h4 id="14-箭头函数区别"><a href="#14-箭头函数区别" class="headerlink" title="14. 箭头函数区别"></a>14. 箭头函数区别</h4><ol>
<li>外形</li>
<li>箭头函数都是匿名函数</li>
<li>箭头函数不能用于构造函数，不能使用new</li>
<li>箭头函数中 this 的指向不同</li>
<li>箭头函数不具有 arguments 对象；每一个普通函数调用后都具有一个arguments 对象，用来存储实际传递的参数</li>
<li>箭头函数不具有 prototype 原型对象。箭头函数不具有 super。箭头函数不具有 new.target</li>
</ol>
<h4 id="15-new创建对象过程"><a href="#15-new创建对象过程" class="headerlink" title="15. new创建对象过程"></a>15. new创建对象过程</h4><ol>
<li><p>创建空对象；<br>　　<code>var obj = &#123;&#125;</code></p>
</li>
<li><p>设置新对象的<code>constructor</code>属性为构造函数的名称，设置新对象的<code>proto</code>属性指向构造函数的<code>prototype</code>对象；<br>　　<code>obj._ proto_ = ClassA.prototype</code></p>
</li>
<li><p>使用新对象调用函数，函数中的<code>this</code>被指向新实例对象：<br>　　<code>ClassA.call(obj);　　//&#123;&#125;.构造函数()</code></p>
</li>
<li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p>
<p>注意：若构造函数中返回this或返回值是<strong>基本类型</strong>的值，则返回<strong>新实例对象</strong></p>
<p>​            若返回值是<strong>引用类型</strong>的值，则实际返回值为引用</p>
</li>
</ol>
<h4 id="16-this指向"><a href="#16-this指向" class="headerlink" title="16. this指向"></a>16. this指向</h4><ul>
<li><p>普通函数</p>
<ol>
<li><code>this</code>总是代表着他的直接调用者，例如<code>obj.fun()</code>，那么<code>fun()中</code>的<code>this</code>就是<code>obj</code>；</li>
<li>调用的时候，没有任何前缀，则指向<code>window</code>，<code>new</code>的时候，指向<code>new</code>出来的对象；</li>
<li>在默认情况下(非严格模式)，没找到直接调动者，则<code>this</code>指向<code>window</code>；</li>
<li>在严格模式下，没有直接调用者的函数中的<code>this</code>是<code>undefined</code>；</li>
<li>使用<code>call、apply、bind</code>绑定的，<code>this</code>指向绑定的对象。</li>
<li>在 <code>Node</code> 中，指向 <code>Global</code></li>
</ol>
</li>
<li><p>箭头函数</p>
<ul>
<li><code>this</code>对象，就是<strong>定义时所在的对象</strong>，而不是使用时所在的对象（并且不可以改变this指向）</li>
<li>不可以当做构造函数，即不能使用<code>new</code></li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在，如果要用可以<code>rest</code>参数替代</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能使用<code>Generator</code>函数</li>
<li>返回对象时必须在对象外面加上括号</li>
</ul>
</li>
<li><p>特殊情景：<strong>this 会 100% 指向 window</strong></p>
<ul>
<li>立即执行函数（IIFE）</li>
<li>setTimeout 中传入的函数</li>
<li>setInterval 中传入的函数</li>
</ul>
</li>
</ul>
<h4 id="17-闭包"><a href="#17-闭包" class="headerlink" title="17. 闭包"></a>17. 闭包</h4><p>优点:</p>
<ul>
<li>可以将一个变量长期储存在内存中，用于缓存</li>
<li>可以避免全局变量的污染</li>
<li>3.加强封装性，是实现了对变量的隐藏和封装</li>
</ul>
<p>缺点:</p>
<ul>
<li>因为函数执行上下文AO执行完不被释放，所以会导致内存消耗很大，增加了内存消耗量，影响网页性能出现问题</li>
<li>而且过度的使用闭包可能会导致内存泄漏，或程序加载运行过慢卡顿等问题的出现</li>
</ul>
<p>应用场景：</p>
<ul>
<li>采用函数引用方式的<code>setTimeout</code>调用</li>
<li>将某一函数中的隐藏数据使用api提供给外界访问</li>
</ul>
<p>调用函数时this指向</p>
<ul>
<li><p>方法调用模式</p>
<p>当一个函数被保存为对象的属性时，称为方法</p>
<p>方法被调用时，this指向 调用者</p>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082212025.png" style="zoom:50%;" />
</li>
<li><p>函数调用模式</p>
<p>指向全局	</p>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082216171.png" style="zoom:80%;" /></li>
</ul>
<p>eg1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="title function_">getNameFunc</span>()());</span><br></pre></td></tr></table></figure>

<p>答案：window</p>
<p>myObject.getNameFunc() 为方法调用，结果为匿名函数 <code>function ()&#123;return this.name;&#125;</code> ，同时 this 指向 myObject</p>
<p>myObject.getNameFunc()() 为函数调用，此时 this 指向全局，所以输出全局变量</p>
<p>eg2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;	</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="title function_">getNameFunc</span>()());</span><br></pre></td></tr></table></figure>

<p>答案：object</p>
<p>myObject.getNameFunc() 为方法调用，此时 that 与 this 同时指向 myObject，所以输出局部变量</p>
<h4 id="18-事件循环"><a href="#18-事件循环" class="headerlink" title="18. 事件循环"></a>18. 事件循环</h4><p>任务分为同步&#x2F;异步</p>
<p>同步进入主线程执行</p>
<p>异步注册回调函数，完成指定任务后进入<code>Event Queue</code>等待主线程完成后执行</p>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082138703.png" style="zoom:50%;" />

<p>注意：<code>promise</code>本身是同步。但是<code>promise</code>的回调<code>then</code>和<code>catch</code>是异步</p>
<p>异步任务分两种：</p>
<ul>
<li><p><code>macro-task</code>(宏任务): </p>
<ul>
<li>整体代码</li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
</ul>
</li>
<li><p><code>micro-task</code>(微任务)：执行于主函数之后，宏任务之前</p>
<ul>
<li><code>Promise</code></li>
<li><code>process.nextTick() //node独有</code></li>
</ul>
</li>
</ul>
<p>宏任务和微任务对应不同的<code>Event Queue</code></p>
<p><strong>顺序</strong>：</p>
<ul>
<li><p>第一次循环：进入整体代码（宏任务）后，接着执行所有微任务</p>
<p>注意：如果在执行<code>microtask</code>的过程中，又产生了<code>microtask</code>，那么会加入到队列的末尾，也会在这个周期</p>
<p>调用执行</p>
</li>
<li><p>第二次循环：再次执行一个宏任务，执行所有微任务</p>
<p>第n次同上</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082139323.png" style="zoom:50%;" />

<p>eg1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​        整体代码作为宏任务开始第一次循环</p>
<ul>
<li><p><strong>输出 1</strong></p>
</li>
<li><p><code>setTimeout</code>的回调函数进入宏任务队列</p>
</li>
<li><p><code>process.nextTick</code>的回调函数排于微队列之前</p>
</li>
<li><p><code>Promise，new Promise</code>直接执行，<strong>输出 7</strong>，<code>then</code>进入微队列</p>
<p>此时第一次宏任务执行完毕，执行所有微任务</p>
</li>
<li><p><code>process.nextTick</code>的回调函数<strong>输出 6</strong></p>
</li>
<li><p><code>then</code><strong>输出 8</strong></p>
<p>第一次<code>Event Loop</code>结束，执行下一个宏任务 <code>setTimeout</code>的回调函数</p>
</li>
<li><p><strong>输出 2</strong></p>
</li>
<li><p><code>process.nextTick</code>的回调函数排于微队列之前</p>
</li>
<li><p><code>Promise，new Promise</code>直接执行，<strong>输出 4</strong>，<code>then</code>进入微队列</p>
<p>此时第二次宏任务执行完毕，执行所有微任务</p>
</li>
<li><p><code>process.nextTick</code>的回调函数<strong>输出 3</strong></p>
</li>
<li><p><code>then</code><strong>输出 5</strong></p>
</li>
</ul>
<p>eg2:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class="line"><span class="comment">// 遇到setTimeout，属于新的宏任务，进入宏任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class="line"><span class="comment">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 console.log(3) 直接打印 3</span></span><br><span class="line"><span class="comment">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class="line"><span class="comment">// 当一次宏任务执行完，并且微任务也清空了, 再去执行新的宏任务，剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure>

<h4 id="19-ts中type和interface区别"><a href="#19-ts中type和interface区别" class="headerlink" title="19. ts中type和interface区别"></a>19. ts中type和interface区别</h4><ul>
<li><p><code>type</code>：类型别名用来给一个类型起个新名字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type userName = string; <span class="comment">// 基本类型</span></span><br><span class="line">type userId = string | number; <span class="comment">// 联合类型</span></span><br><span class="line">type arr = number[];  </span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line">type <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: userId; <span class="comment">// 可以使用定义类型</span></span><br><span class="line">    <span class="attr">name</span>: userName;</span><br><span class="line">    <span class="attr">age</span>: number;</span><br><span class="line">    <span class="attr">gender</span>: string;</span><br><span class="line">    <span class="attr">isWebDev</span>: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 范型</span></span><br><span class="line">type <span class="title class_">Tree</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;901&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;椿&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">    <span class="attr">isWebDev</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">numbers</span>: arr = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>interface</code>：命名数据结构（例如对象）的另一种方式；与type 不同，interface仅限于描述对象类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: userId;</span><br><span class="line">    <span class="attr">name</span>: userName;</span><br><span class="line">    <span class="attr">age</span>: number;</span><br><span class="line">    <span class="attr">gender</span>: string;</span><br><span class="line">    <span class="attr">isWebDev</span>: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相同点：</p>
<ol>
<li><p>都可以描述 Object和Function（但语法不同）</p>
<ul>
<li><p><code>type</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: number;</span><br><span class="line">  <span class="attr">y</span>: number;</span><br><span class="line">&#125;;</span><br><span class="line">type <span class="title class_">SetPoint</span> = <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> <span class="keyword">void</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>interface</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: number;</span><br><span class="line">  <span class="attr">y</span>: number;</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">SetPoint</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>: number, <span class="attr">y</span>: number): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二者都可以被继承（相互都可以）</p>
<ul>
<li><p><code>interface</code>继承<code>interface</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:string</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123; <span class="attr">stuNo</span>: number &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>interface</code>继承<code>type</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:string</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123; <span class="attr">stuNo</span>: number &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code>继承<code>type</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:string</span><br><span class="line">&#125;</span><br><span class="line">type <span class="title class_">Student</span> = <span class="title class_">Person</span> &amp; &#123; <span class="attr">stuNo</span>: number &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code>继承<code>interface</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:string</span><br><span class="line">&#125;</span><br><span class="line">type <span class="title class_">Student</span> = <span class="title class_">Person</span> &amp; &#123; <span class="attr">stuNo</span>: number &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实现 implements</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">ICat</span>&#123;</span><br><span class="line">    <span class="title function_">setName</span>(<span class="attr">name</span>:string): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> implements <span class="title class_">ICat</span>&#123;</span><br><span class="line">    <span class="title function_">setName</span>(<span class="attr">name</span>:string):<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type  </span></span><br><span class="line">type <span class="title class_">ICat</span> = &#123;</span><br><span class="line">    <span class="title function_">setName</span>(<span class="attr">name</span>:string): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> implements <span class="title class_">ICat</span>&#123;</span><br><span class="line">    <span class="title function_">setName</span>(<span class="attr">name</span>:string):<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊情况：类无法实现联合类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: string; &#125; | &#123; <span class="title function_">setName</span>(<span class="attr">name</span>:string): <span class="keyword">void</span> &#125;;</span><br><span class="line"><span class="comment">// 无法对联合类型Person进行实现</span></span><br><span class="line"><span class="comment">// error: A class can only implement an object type or intersection of object types with statically known members.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> implements <span class="title class_">Person</span> &#123;</span><br><span class="line">  name= <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="attr">name</span>:string):<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>区别：</p>
<ol>
<li><p><code>type</code>可以定义基本类型别名, 但是<code>interface</code>无法定义</p>
</li>
<li><p><code>type</code>可以声明联合类型</p>
<p>eg：<code>type Student = &#123;stuNo: number&#125; | &#123;classId: number&#125;</code></p>
</li>
<li><p><code>type</code>可以声明 元组类型</p>
<p>eg：<code>type Data = [number, string];</code></p>
</li>
<li><p>声明合并：多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Person</span> &#123; <span class="attr">name</span>: string &#125;</span><br><span class="line">interface <span class="title class_">Person</span> &#123; <span class="attr">age</span>: number &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tolu&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下，如果是type的话，重复使用Person是会报错的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Person</span> &#123; <span class="attr">name</span>: string &#125;;  </span><br><span class="line"><span class="comment">// Error: 标识符“Person”重复。ts(2300)</span></span><br><span class="line">type <span class="title class_">Person</span> &#123; <span class="attr">age</span>: number &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相似的错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Type</span> <span class="string">&#x27;xxx&#x27;</span> is not assignable to type <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line"><span class="title class_">Index</span> signature is missing <span class="keyword">in</span> type <span class="string">&#x27;xxx&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface propType&#123;</span><br><span class="line">    [<span class="attr">key</span>: string] : string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">props</span>: propType</span><br><span class="line">type dataType = &#123;</span><br><span class="line">    <span class="attr">title</span>: string</span><br><span class="line">&#125;</span><br><span class="line">interface dataType1 &#123;</span><br><span class="line">    <span class="attr">title</span>: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: dataType = &#123;<span class="attr">title</span>: <span class="string">&quot;订单页面&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">data1</span>: dataType1 = &#123;<span class="attr">title</span>: <span class="string">&quot;订单页面&quot;</span>&#125;</span><br><span class="line">props = data</span><br><span class="line"><span class="comment">// Error:类型“dataType1”不可分配给类型“propType”; 类型“dataType1”中缺少索引签名  </span></span><br><span class="line">props = data1</span><br></pre></td></tr></table></figure>

<p><code>Record&lt;string,string&gt;与&#123;[key:string]：string&#125;</code>相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。在您的例子中，从<code>exampleType</code>到<code>Record&lt;string,string&gt;</code>的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的</p>
<p>相反，在你使用<code>interface</code>去声明变量时，它们在那一刻类型并不是最终的类型。由于<code>interface</code>可以进行声明合并，所以总有可能将新成员添加到同一个<code>interface</code>定义的类型上</p>
<p>结合声明合并的讲解，即<code>interface</code>定义的类型是不确定的，后面需加上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface propType&#123;</span><br><span class="line">    <span class="attr">title</span>:number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样<code>propType</code>类型就被改变了</p>
</li>
</ol>
</li>
</ul>
<h4 id="20-ts中的泛型"><a href="#20-ts中的泛型" class="headerlink" title="20. ts中的泛型"></a>20. ts中的泛型</h4><h4 id="21-CommonJs与ESModule的区别"><a href="#21-CommonJs与ESModule的区别" class="headerlink" title="21. CommonJs与ESModule的区别"></a>21. CommonJs与ESModule的区别</h4><ol>
<li><p>两者的模块导入导出语法不同，<code>CommonJs</code>是通过<code>module.exports，exports</code>导出，<code>require</code>导入；</p>
<p><code>ESModule</code>则是<code>export</code>导出，<code>import</code>导入。</p>
</li>
<li><p><code>CommonJs</code>是运行时加载模块，<code>ESModule</code>是在静态编译期间就确定模块的依赖。</p>
</li>
<li><p><code>ESModule</code>在编译期间会将所有<code>import</code>提升到顶部，<code>CommonJs</code>不会提升<code>require</code>。</p>
</li>
<li><p><code>CommonJs</code>导出的是一个值拷贝，会对加载结果进行缓存，一旦内部再修改这个值，则不会同步到外部。</p>
<p><code>ESModule</code>是导出的一个引用，内部修改可以同步到外部。</p>
</li>
<li><p><code>CommonJs</code>中顶层的<code>this</code>指向这个模块本身，而<code>ESModule</code>中顶层<code>this</code>指向<code>undefined</code>。</p>
</li>
<li><p><code>CommonJS</code>加载的是整个模块，将所有的接口全部加载进来，<code>ESModule</code>可以单独加载其中的某个接口</p>
</li>
</ol>
<h4 id="22-柯里化"><a href="#22-柯里化" class="headerlink" title="22. 柯里化"></a>22. 柯里化</h4><p><strong>柯里化</strong> 是一种转换，将 <code>f(a,b,c)</code> 转换为可以被以 <code>f(a)(b)(c)</code> 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数</p>
<p>柯里化让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数</p>
<ul>
<li><p>简单实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">f</span>) &#123; <span class="comment">// curry(f) 执行柯里化转换</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">f</span>(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = <span class="title function_">curry</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">curriedSum</span>(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>高级实现<code>lodash 库的 [_.curry]</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = _.<span class="title function_">curry</span>(sum); <span class="comment">// 使用来自 lodash 库的 _.curry</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">curriedSum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3，仍可正常调用</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">curriedSum</span>(<span class="number">1</span>)(<span class="number">2</span>) ); <span class="comment">// 3，以偏函数的方式调用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="23-垃圾回收机制"><a href="#23-垃圾回收机制" class="headerlink" title="23. 垃圾回收机制"></a>23. 垃圾回收机制</h4><p>Gabage Collection（GC）</p>
<p>定义：</p>
<ul>
<li>程序中不再需要使用的对象</li>
<li>程序中不能再访问到的对象</li>
</ul>
<p>常见回收算法：</p>
<ul>
<li><p>引用计数</p>
<ul>
<li>原理：内部通过引用计数器，来维护当前对象的引用数，从而判断该对象的引用数是否为0，来决定它是否是一个垃圾对象。如果引用数值为0,GC就开始工作，将其所在的内存空间进行回收释放和再使用</li>
<li>引用计数器：当某一个对象的引用关系发生改变时，引用计数器就会自动的修改这个对象所对应的引用数值（比如我们代码中有一个对象空间，一个变量引用了它，那么这个对象空间的引用数值加1） 引用数值为0的时候GC就开始工作，将当前的对象空间回收</li>
<li>优点：<strong>可以即时回收垃圾对象、减少程序卡顿时间。</strong><ul>
<li>发现垃圾立即回收</li>
<li>最大限度的减少程序暂停（应用程序在执行的过程中必定会对内存进行消耗，而当前的执行平台内存空间是有上限的，所以内存肯定会有占满的时候。由于引用计数算法时刻监控着那些引用数值为0的对象，当内存爆满的时候会去找那些引用数值为0的对象释放其内存，这个也就保证了当前的内存空间不会有占满的时候）</li>
</ul>
</li>
<li>缺点：<strong>无法回收循环引用的对象、资源消耗较大</strong><ul>
<li>无法回收循环引用的对象</li>
<li>时间开销大（当前的引用计数需要去维护一个数值的变化，时刻监控当前引用数值是否修改，修改需要时间）</li>
</ul>
</li>
</ul>
</li>
<li><p>标记清除</p>
<ul>
<li><p>原理：</p>
<ol>
<li>遍历所有的对象找到活动对象，进行标记的操作</li>
<li>遍历所有的对象，找到那些没有标记的对象进行清除。(注意在第二阶段中也会把第一阶段涉及的标志给抹掉，便于GC下次能够正常的工作)</li>
</ol>
<p> 总结：分标记和清除两个阶段</p>
</li>
<li><p>优点：</p>
<ul>
<li><p>实现简单</p>
</li>
<li><p>可以回收循环引用的对象空间。</p>
</li>
<li><p>V8引擎使用最多</p>
</li>
</ul>
</li>
<li><p>缺点：容易产生碎片化空间，浪费空间、不能立即回收垃圾对象</p>
</li>
</ul>
</li>
<li><p>标记整理</p>
<p>标记结束后标记整理算法会将不需要清理的对象向内存一端移动，最后清理边界的内存</p>
</li>
</ul>
<h4 id="24-V8引擎的垃圾回收"><a href="#24-V8引擎的垃圾回收" class="headerlink" title="24. V8引擎的垃圾回收"></a>24. V8引擎的垃圾回收</h4><ul>
<li>采用<strong>标记清除法</strong>与<strong>分代回收法</strong></li>
<li>分为<strong>新生代</strong>和<strong>老生代</strong><ul>
<li><strong>新生代</strong>：对象的存活时间较<strong>短</strong>。新生对象或只经过一次垃圾回收的对象<ul>
<li>主要采用复制算法（<code>Scavenge</code> 算法）加标记整理算法。而<code>Scavenge</code> 算法的具体实现，主要采用了<code>Cheney</code>算法<ul>
<li><code>Cheney</code>(对象晋升机制)：一轮GC还存活的新生代需要晋升</li>
</ul>
</li>
</ul>
</li>
<li><strong>老生代</strong>：对象存活时间较<strong>长</strong>。经历过一次或多次垃圾回收的对象<ul>
<li>主要采用标记清除、标记整理、增量标记算法；主要使用标记清除算法，只有在内存分配不足时，采用标记整理算法<ul>
<li>首先使用<strong>标记清除</strong>完成垃圾空间的回收；</li>
<li>采用<strong>标记整理</strong>进行<strong>空间优化</strong>；</li>
<li>采用<strong>增量标记</strong>进行<strong>效率优化</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="25-发布订阅"><a href="#25-发布订阅" class="headerlink" title="25. 发布订阅"></a>25. 发布订阅</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> listeners = <span class="variable language_">this</span>.<span class="property">subscribers</span>[type] || [];</span><br><span class="line">        listeners.<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> listeners = <span class="variable language_">this</span>.<span class="property">subscribers</span>[type];</span><br><span class="line">        <span class="keyword">if</span> (!listeners || !listeners.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subscribers</span>[type] = listeners.<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v !== fn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">publish</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> listeners = <span class="variable language_">this</span>.<span class="property">subscribers</span>[type];</span><br><span class="line">        <span class="keyword">if</span> (!listeners || !listeners.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line">        listeners.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(...args));        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ob = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line">ob.<span class="title function_">subscribe</span>(<span class="string">&#x27;add&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val));</span><br><span class="line">ob.<span class="title function_">publish</span>(<span class="string">&#x27;add&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>定义一个变量存储这些事件</p>
</li>
<li><p>定义一个监听方法，用于把事件添加到事件变量中</p>
</li>
<li><p>定义一个删除方法，用于把是事件从变量中移除</p>
</li>
<li><p>定义一个触发方法，用于调用变量中的事件</p>
<p>使用方式类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面A订阅LOGIN事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;LOGIN&#x27;</span>, handle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录成功，触发发布</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;LOGIN&#x27;</span>, &#123;<span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Jan&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>具体代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">EventEmitter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 事件变量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_event</span> = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加订阅</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">on</span>= <span class="keyword">function</span> (<span class="params">type, handle</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_event</span>[type] = <span class="variable language_">this</span>.<span class="property">_event</span>[type] || []</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_event</span>[type].<span class="title function_">push</span>(handle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除订阅</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span> (<span class="params">type, handle</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = (<span class="variable language_">this</span>.<span class="property">_event</span>[type] || []).<span class="title function_">indexOf</span>(handle)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_event</span>[type].<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发发布</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span> (<span class="params">type, data</span>) &#123;</span><br><span class="line">    (<span class="variable language_">this</span>.<span class="property">_event</span>[type] || []).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">handle</span>) &#123;</span><br><span class="line">        <span class="title function_">handle</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>优点：<ul>
<li>时间上的解耦：在异步编程中，由于无法确定异步加载的时间，有可能订阅事件的模块还没有初始化完毕而异步加载就完成了，发布者就已经发布事件了。通过发布订阅模式，可以将发布者的事件提前保存起来，等到发布者加载完毕再执行</li>
<li>对象间的解耦：发布订阅模式中，发布者和订阅者可以不必知道对方的存在，而是通过中介对象来通信。</li>
</ul>
</li>
<li>缺点：<ul>
<li>创建订阅者本身需要一定的时间和内存，而当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中</li>
<li>发布订阅模式将对象间完全解耦，如果过度使用的话，对象和对象之间的必要联系就会被掩盖，会导致程序难以追踪和理解</li>
</ul>
</li>
</ul>
<h4 id="26-观察者模式"><a href="#26-观察者模式" class="headerlink" title="26. 观察者模式"></a>26. 观察者模式</h4><p>  它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>
<p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221204213521.png"></p>
<ul>
<li><p>从图中可以看出，<strong>观察者模式</strong>中观察者和目标<strong>直接进行交互</strong></p>
<p>而<strong>发布订阅模式</strong>中统一由<strong>调度中心进行处理</strong>，订阅者和发布者互不干扰。</p>
</li>
<li><p><strong>观察者模式</strong>的订阅者与发布者之间是存在依赖的，而<strong>发布&#x2F;订阅模式</strong>则不会。</p>
<p>注意：发布&#x2F;订阅模式优势在于， 这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">val</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverList</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span> = <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">ob</span> =&gt;</span> ob !== observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">observerList</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目标</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">ObserverList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">add</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">removeObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">remove</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> obCount = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">count</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; obCount; index++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">get</span>(i).<span class="title function_">update</span>(...args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：从上面代码可以看出，<strong>观察者模式</strong>由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余。</p>
<p>而<strong>发布订阅模式</strong>则统一由调度中心处理，消除了发布者和订阅者之间的依赖。</p>
<h4 id="27-数组去重"><a href="#27-数组去重" class="headerlink" title="27. 数组去重"></a>27. 数组去重</h4><ol>
<li><p><code>Array.from + set</code> (ES6常用)<br><code>console.log(Array.from(new Set(arr))) //from将一个类数组对象或者可遍历对象转换成一个真正的数组</code></p>
<p>缺点：无法去掉<code>&#123;&#125;</code>空对象</p>
</li>
<li><p><code>for嵌套for，然后splice去重</code>（ES5中最常用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.<span class="property">length</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">                    arr.<span class="title function_">splice</span>(j,<span class="number">1</span>);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：<code>NaN</code>和<code>&#123;&#125;</code>没有去重，两个<code>null</code>直接消失</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>indexOf</code>（判断数组中是否存在，不存在返回<code>-1</code>，存在返回索引值）：</p>
<p>新建一个空数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array .<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array .<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：NaN、{}没有去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line">   <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filter()</code>：<code>array.filter(function(currentValue,index,arr), thisValue)</code>  &#x2F;&#x2F;数组中的每个元素都会执行这个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniqueArr</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span></span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item,index,array</span>) =&gt;</span> array.<span class="title function_">indexOf</span>(item) === index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Map</code>：map中不会有重复元素</p>
</li>
</ol>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="1-hook"><a href="#1-hook" class="headerlink" title="1. hook"></a>1. hook</h4><p><strong>React 不允许 hook 处于条件语句</strong>：</p>
<p>  React 把每次 render 中 useState 的顺序值 0、1、2、3 当成了 key，方便后续 render 用 key 查找对应的 state。这样的目的是使 useState 更简洁。 注意：因为我们保证了 hooks 的调用顺序（不保证就会报错），所以 hooks 内部可以使用链表来实现，而不要因果倒置。</p>
<ul>
<li><p>useState</p>
<p>异步</p>
</li>
<li><p>useEffect</p>
<ol>
<li>每次渲染都要执行：则第二个参数不需要</li>
<li>在组件销毁或者调用函数前调用：则第一个参数中增加return语句</li>
<li>只在组件挂载时执行一次：则第二个参数用空数组:[]</li>
<li>只在某一个state或者prop值发生变化后，才执行：则第二个参数[变量名]</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    effect<span class="comment">//每次渲染时执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        cleanup<span class="comment">//清除时执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [input])<span class="comment">//input是控制的变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>useContext</p>
<p>组件间通信</p>
<ul>
<li>context可以是非父组件，只要是祖先即可，而且是最近的那个</li>
<li>提取的是value值</li>
<li>上层组件或本组件context的value值更新都会重新渲染</li>
<li>使用下层组件需要使用<code>&lt;MyContext.Provider&gt;</code>包裹</li>
</ul>
</li>
<li><p><strong>自定义hook</strong></p>
<p><strong>逻辑的复用</strong>，类似于方法</p>
<ul>
<li>自定义hook中可以调用其他hook</li>
<li>必须以use开头，就像组件必须以大写字母开头一样</li>
<li>自定义hook中管理state也是使用useState、useEffect，因为useState在调用的时候就是完全独立的</li>
</ul>
</li>
</ul>
<h4 id="2-React-diff"><a href="#2-React-diff" class="headerlink" title="2. React diff"></a>2. React diff</h4><ul>
<li><p>Diff算法的限制策略： </p>
<ul>
<li>只对<strong>同级元素</strong>进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。</li>
<li>两个<strong>不同类型</strong>的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。</li>
<li>开发者可以通过 <code>key</code>属性 来暗示哪些子元素在不同的渲染下能保持稳定（即是否可<strong>稳定复用</strong>）</li>
</ul>
</li>
<li><p>不同类型</p>
<ul>
<li><p>同级的节点数量将Diff分为两类：</p>
<ul>
<li><p>当<code>newChild</code>类型为<code>object、number、string，</code>代表同级只有一个节点</p>
<p>React通过先判断该节点的<code>key</code>是否相同，如果<code>key``相同再判断节点类型</code>type&#96;是否相同，只有二者都相同时，那么这个DOM节点才能复用</p>
</li>
<li><p>当<code>newChild</code>类型为<code>Array</code>，同级有多个节点</p>
<p>用新集合中的节点去和老集合中的节点进行diff：</p>
<ul>
<li><p>diff结束后，如果新集合中还有未进行diff的节点，说明该节点是需要新增的，对该节点执行新增逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=&quot;0&quot;&gt;0&lt;li&gt;</span><br><span class="line">    &lt;li key=&quot;1&quot;&gt;1&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 之后情况1 新增节点</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=&quot;0&quot;&gt;0&lt;li&gt;</span><br><span class="line">    &lt;li key=&quot;1&quot;&gt;1&lt;li&gt;</span><br><span class="line">    &lt;li key=&quot;2&quot;&gt;2&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>diff结束后，如果老集合中还有未进行diff的节点，说明该节点是需要删除的，对该节点执行删除逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=&quot;0&quot;&gt;0&lt;li&gt;</span><br><span class="line">    &lt;li key=&quot;1&quot;&gt;1&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// 之后情况2 删除节点</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=&quot;0&quot;&gt;0&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>diff结束后，如果新老集合都还有未进行diff的节点，说明在diff过程中，出现了不可复用的节点，对该节点进行更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line">            &lt;li key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/li&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>diff结束后，如果新老集合中的节点刚好diff完，</p>
<p>（1）新旧集合中存在相同节点，并且位置相同，无需移动节点。</p>
<p>（2）新旧集合中存在相同节点但位置不同时，需要移动对老集合中的节点进行移动处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=&quot;0&quot;&gt;0&lt;li&gt;</span><br><span class="line">    &lt;li key=&quot;1&quot;&gt;1&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 之后</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=&quot;1&quot;&gt;1&lt;li&gt;</span><br><span class="line">    &lt;li key=&quot;0&quot;&gt;0&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>lastIndex</code>：来做顺序优化，通过这个变量判断节点是否需要移动</p>
<ul>
<li><p>默认值是<code>0</code>，它会与<code>map</code>中的元素进行比较，满足 <code>index &lt; lastIndex</code> 的条件时，进行移动操作并改变值</p>
<p><code>lastIndex = max(index,lastIndex)</code></p>
<p>eg：<img src="https://raw.githubusercontent.com/LVZJself/image/main/20221206154324.png"></p>
<ol>
<li>React先从新中取得B，然后判断旧中是否存在相同节点B，当发现存在节点B后，就去判断是否移动B。<br>   B在旧中的<code>index=1</code>，它的<code>lastIndex=0</code>，不满足<code> index &lt; lastIndex</code> 的条件，因此 B 不做移动操作。此时，<code>lastIndex=(index,lastIndex)</code>中的较大数<code>=1</code>.</li>
<li>看着 A，A在旧的<code>index=0</code>，此时的<code>lastIndex=1</code>（因为先前与新的B比较过了），满足<code>index&lt;lastIndex</code>，因此，对A进行移动操作，此时<code>lastIndex=max(index,lastIndex)=1</code>。</li>
<li>看着D，D在旧的<code>index=3</code>，此时<code>lastIndex=1</code>, 不满足<code>index&lt;lastIndex</code>, 所以不移动。比较完后，<code>lastIndex=max(index,lastIndex)=3</code></li>
<li>看着C，C在旧的<code>index=2</code>，此时<code>lastIndex=3</code>, 满足<code>index&lt;lastIndex</code>，所以C进行移动。<br>由于C已经是最后一个节点，所以diff操作结束。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-组件复用"><a href="#3-组件复用" class="headerlink" title="3. 组件复用"></a>3. 组件复用</h4><ul>
<li><p><code>HOC</code></p>
</li>
<li><p><code>Render Props</code></p>
<p>简单来说就是在被复用的组件中，通过一个名为render(属性名也可以不是render，只要值是一个函数即可)的prop属性，该属性是一个函数，这个函数接受一个对象并返回一个子组件，会将这个函数参数中的对象作为props传入给新生成的组件，而在使用调用者组件这里，只需要决定这个组件在哪里渲染以及该以何种逻辑渲染并传入相关对象即可。</p>
</li>
<li><p><code>Hooks</code></p>
<p>将可复用逻辑抽离成函数</p>
</li>
</ul>
<h4 id="4-React-fiber"><a href="#4-React-fiber" class="headerlink" title="4. React fiber"></a>4. React fiber</h4><p><code>React Fiber</code>是对核心算法的一次重新实现</p>
<p>v16版本发布<code>fiber reconciler</code>，之前称为<code>stack reconciler</code></p>
<p><code>React Fiber</code> 把更新过程碎片化，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务</p>
<p>做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务</p>
<p>解决：渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差</p>
<ul>
<li>一个 <code>fiber</code>（小写’f’）是一个简单的 JavaScript 对象。它代表 React 元素或 DOM 树的一个节点。它是一个工作单位。</li>
<li>相比之下，<code>Fiber</code> 是 <code>React Fiber</code> 的协调器</li>
</ul>
<h4 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h4><p>废除的函数：</p>
<p>  原因：在render函数之前的所有函数，都有可能被执行多次</p>
<ul>
<li>componentWillMount</li>
<li>componentWillRecieveProps</li>
<li>componentWIllUpdate</li>
</ul>
<p>三个阶段</p>
<p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221207195610.png"></p>
<p>新增</p>
<ul>
<li><p>挂载阶段：也被称为初始化阶段，表示组件第一次在DOM树中进行渲染的过程</p>
<ul>
<li><p><code>getDerivedStateFromProps</code>：</p>
<p>只要页面<code>update</code>就会被触发；从<code>props</code>中获取<code>state</code>；返回值是一个对象，这个对象的作用和<code>setState</code>一样用于更新<code>state</code>，返回值为<code>null</code>时，不更新<code>state</code>状态。提供给我们一个在渲染之前操作<code>state</code>的机会</p>
</li>
</ul>
</li>
<li><p>更新阶段：也叫存在阶段，表示组件被重新渲染的过程</p>
<ul>
<li><p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>：</p>
<p><code>update</code>发生的时候，在<code>render</code>之后可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息</p>
</li>
</ul>
</li>
<li><p>卸载阶段：也叫销毁阶段，表示组件从DOM中删除的过程</p>
</li>
<li><p>新增错误处理：<code>componentDidCatch(error，info)</code>：任何一处的javascript报错会触发</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/27/bagu/" data-id="clazhl5nf0000xgbhcppw5qj6" data-title="八股" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/07/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2022-10-07T15:42:57.000Z" itemprop="datePublished">2022-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/07/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/">算法题记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221009225813.png" style="zoom: 67%;" />

<p>思路：用set模拟滑动窗口，set .has&#x2F;add&#x2F;delete 方法来实现窗口的出入功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getLongest = <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> rp = -<span class="number">1</span>, ans = <span class="number">0</span>;<span class="comment">//rp右指针，初始值为-1保证在指向下一字符时不过界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> lp = <span class="number">0</span>; lp &lt; n; lp++)&#123;</span><br><span class="line">        <span class="comment">//窗口左边界移一位</span></span><br><span class="line">        <span class="keyword">if</span>(lp != <span class="number">0</span>)&#123;</span><br><span class="line">            x.<span class="title function_">delete</span>(s.<span class="title function_">charAt</span>(lp - <span class="number">1</span>));<span class="comment">//排除lp=0即第一次循环时的情况，此时Set内无元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口右边界循环至遇到重复元素</span></span><br><span class="line">        <span class="keyword">while</span>(!x.<span class="title function_">has</span>(s.<span class="title function_">charAt</span>(rp + <span class="number">1</span>)) &amp;&amp; rp + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">            x.<span class="title function_">add</span>(s.<span class="title function_">charAt</span>(rp + <span class="number">1</span>));</span><br><span class="line">            rp++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, rp - lp + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)；窗口左右边界分别遍历一次数组</p>
<p>空间复杂度：<em>O</em>(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符）</p>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221010142047.png"></p>
<p>思路：给定的 nums1 后n位为空，所以以 nums2 全部插入 nums1 中为结束标志；利用已经排序好的特性，比较尾端大小即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> p = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="comment">//两指针都完成数组遍历时结束</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 === -<span class="number">1</span>) &#123;</span><br><span class="line">            value = nums2[p2]; p2--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 === -<span class="number">1</span>) &#123;</span><br><span class="line">            value = nums1[p1]; p1--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">            value = nums1[p1]; p1--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = nums2[p2]; p2--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[p] = value; p--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m + n)</p>
<p>空间复杂度：O(1)；直接在nums[1]中存储</p>
<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221010161040.png"></p>
<p>思路：将版本号按 ‘ . ’ 分割成修订号进行比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVertion = <span class="keyword">function</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = version1.<span class="property">length</span>, n2 = version2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//比较至两个版本号都为最后一位时结束，每次循环比较一个修订号</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 || j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">0</span>;<span class="comment">//每次循环重置暂放修订号的x，并保证没有该位版本号时其值为 0</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n1 &amp;&amp; version1.<span class="title function_">charAt</span>(i) !== <span class="string">&#x27;.&#x27;</span>; ++i) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + version1.<span class="title function_">charCodeAt</span>(i) - <span class="string">&#x27;0&#x27;</span>.<span class="title function_">charCodeAt</span>();<span class="comment">//通过unicode规避前导零</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;<span class="comment">//跳过‘.’</span></span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; n2 &amp;&amp; version2.<span class="title function_">charAt</span>(j) !== <span class="string">&#x27;.&#x27;</span>; ++j) &#123;</span><br><span class="line">            y = y * <span class="number">10</span> + version2.<span class="title function_">charCodeAt</span>(j) - <span class="string">&#x27;0&#x27;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span> (x !== y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n + m)</p>
<p>空间复杂度：O(n + m)</p>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221010172000.png"></p>
<p>思路：利用堆栈的结构，将右括号与栈顶的左括号对比；并在对比结束后观察栈的长度来判断是否匹配</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">//个数为奇数提前判断</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用Map构建Hash结构</span></span><br><span class="line">    <span class="keyword">let</span> pairs = <span class="keyword">new</span> <span class="title class_">Map</span> ([</span><br><span class="line">        [<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>]</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pairs.<span class="title function_">has</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs.<span class="title function_">get</span>(ch) !== stack[stack.<span class="property">length</span> - <span class="number">1</span>] || !stack.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span>;<span class="comment">//利用‘！’得到Boolean型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N + 字符集)</p>
<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h2><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221011153727.png" style="zoom: 67%;" />

<p>思路：选用递归</p>
<ol>
<li>如果节点为空，返回false</li>
<li>如果为叶子节点，判断该节点值是否与传入的targetSum相等</li>
<li>如果不为叶子节点，递归查询 该节点的左右节点的值 与 (targetSum - 该节点的值) 的关系</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root.<span class="property">right</span> &amp;&amp; !root.<span class="property">left</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">val</span> === targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用 ‘||’ 连接，保证查询左右节点</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="title function_">hasPathSum</span>(root.<span class="property">left</span>, targetSum - root.<span class="property">val</span>) || <span class="title function_">hasPathSum</span>(root.<span class="property">right</span>, targetSum - root.<span class="property">val</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)，n为树节点数量</p>
<p>空间复杂度：O(H)，h为树的高度</p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221011161012.png" style="zoom:80%;" />

<p>思路：利用哈希结构，在一次循环内边插入边比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>, len = nums.<span class="property">length</span>; x &lt; len; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(target - nums[x])) &#123;</span><br><span class="line">            <span class="keyword">return</span> [x, map.<span class="title function_">get</span>(target - nums[x])];</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="title function_">set</span>(nums[x], x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)，n为数组元素数量</p>
<p>空间复杂度：O(N)，n为数组元素数量</p>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221011161339.png" style="zoom:67%;" />

<p><strong>思路1</strong>：动态规划。</p>
<p>用f(i)表示以第i个数结尾的 连续子数组的最大和，那题目转化为求<img src="https://raw.githubusercontent.com/LVZJself/image/main/20221011164645.png" style="zoom: 80%;" /></p>
<p>f(i)就可以得出：<img src="https://raw.githubusercontent.com/LVZJself/image/main/20221011164758.png" style="zoom: 80%;" /></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        value = <span class="title class_">Math</span>.<span class="title function_">max</span>(x + value, x);</span><br><span class="line">        maxAns = <span class="title class_">Math</span>.<span class="title function_">max</span>(value, maxAns);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> maxAns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，n为数组长度</p>
<p>空间复杂度：O(1)</p>
<p><strong>思路2</strong>：分治</p>
<p>定义一个操作 <code>get(a, l, r)</code> 表示查询 a 序列[l, r]区间内的最大子段和</p>
<p>答案就转化为 <code>get(nums, 0, nums.size() - 1)</code></p>
<p>维护[l, r]区间四个量</p>
<ul>
<li><strong>lSum</strong>：以<strong>l</strong>为左端点的最大区间和</li>
<li><strong>rSum</strong>：以<strong>r</strong>为右端点的最大区间和</li>
<li><strong>mSum</strong>：最大区间和</li>
<li><strong>iSum</strong>：区间和</li>
</ul>
<p>取 m &#x3D; (l + r)&#x2F;2</p>
<p>对于左子区间[l, m]和右子区间[m+1, r]得到[l, r]四个量的方式：</p>
<ul>
<li><strong>lSum</strong>：两种可能 <ol>
<li>左子区间的<strong>lSum</strong> </li>
<li>左子区间的<strong>iSum</strong> + 右子区间<strong>lSum</strong></li>
</ol>
</li>
<li><strong>rSum</strong>：两种可能同理</li>
<li><strong>iSum</strong>：左<strong>iSum</strong> + 右<strong>iSum</strong></li>
<li><strong>mSum</strong>： 三种可能<ol>
<li>左子区间的<strong>mSum</strong></li>
<li>右子区间的<strong>mSum</strong></li>
<li>左子区间的<strong>rSum</strong> + 右子区间的<strong>lSum</strong></li>
</ol>
</li>
</ul>
<p>复杂度分析：</p>
<p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221011201040.png"></p>
<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221012191240.png"></p>
<p>思路：使用两指针指向字符串末尾，当位数短的指针下标为负数时返回0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addStrings = <span class="keyword">function</span>(<span class="params">nums, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>, j = num2.<span class="property">length</span> - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = i &gt;= <span class="number">0</span> ? num1.<span class="title function_">charAt</span>(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;<span class="comment">//字符串相减</span></span><br><span class="line">        <span class="keyword">const</span> y = j &gt;= <span class="number">0</span> ? num2.<span class="title function_">charAt</span>(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> result = x + y + add;</span><br><span class="line">        ans.<span class="title function_">push</span>(result % <span class="number">10</span>);</span><br><span class="line">        add = <span class="title class_">Math</span>.<span class="title function_">floor</span>(result / <span class="number">10</span>);<span class="comment">//floor（x）将返回小于x的最大整数</span></span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);<span class="comment">//reverse将数组顺序反转，join将数组变为字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a>129. 求根节点到叶节点数字之和</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221012222730.png"></p>
<p>思路：递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNumbers = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">recurse</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">recurse</span>(<span class="params">root, value</span>) &#123;</span><br><span class="line">        value = value * <span class="number">10</span> + root.<span class="property">val</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            sum += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">left</span>) &#123;</span><br><span class="line">            <span class="title function_">recurse</span>(root.<span class="property">left</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="title function_">recurse</span>(root.<span class="property">right</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215. 数组中的第k个最大元素"></a>215. 数组中的第k个最大元素</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221012224607.png"></p>
<p>思路：快速排序，返回排序后下下标为k</p>
<p>可以简化为快速选择：当划分第一次完成时，比较目标索引与找到的索引，进而只递归一边的子区间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> targetIndex = len - k;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="title function_">partition</span>(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index === targetIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; targetIndex) &#123;</span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">nums, start, end</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> povit = nums[start];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] &gt;= povit) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] &lt; povit) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = povit;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<em>O</em>(<em>n</em>)</p>
<p>空间复杂度：O*(log<em>n)，递归使用栈空间的空间代价的期望为 O</em>(log*n)</p>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221013153244.png"></p>
<p>思路：常规做法三重循环，但我们可以简化为二重循环。</p>
<p>在该题目中，’三数之和等于零‘的限制条件使得第二、三重循环可以同时进行，第二重每次循环时判断三数之和的大小，利用数组已经排序好，和大于零就移动左指针，小于零就移动右指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (!nums || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//i&gt;0保证特殊情况 0 0 0不被排除</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="title function_">push</span>([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(${n^2}$)，排序时间复杂度O($Nlog N$) 小于O(${n^2}$)，忽略</p>
<p>空间复杂度：O($log N$)，忽略存储答案的空间，只考虑排序的</p>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221013161454.png"></p>
<p>思路：动态规划，定义一个最大利润和历史最低点，每一天只更新两者</p>
<p>同时将最大利润初值定为0，保证无利润时返回0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>, min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        min = <span class="title class_">Math</span>.<span class="title function_">min</span>(min, prices[i]);</span><br><span class="line">        max = (prices[i] - min) &gt; max ? prices[i] - min : max;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221013195725.png"></p>
<p>思路：dfs，但是每次获取一层的索引而不是一个</p>
<p>用队列每次存储一层的节点，每次出队的同时入队他的左右子节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">const</span> q = [];</span><br><span class="line">    q.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curLevelSize = q.<span class="property">length</span>;</span><br><span class="line">        ret.<span class="title function_">push</span>([]);<span class="comment">//ret添加一层节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= curLevelSize; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = q.<span class="title function_">shift</span>();<span class="comment">//删除第一个节点并返回他</span></span><br><span class="line">            ret[ret.<span class="property">length</span> - <span class="number">1</span>].<span class="title function_">push</span>(node.<span class="property">val</span>);<span class="comment">//ret[ret.length - 1]为承载当前层的数组</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span>) q.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span>) q.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221014160011.png" style="zoom:80%;" />

<p>思路：回溯，用path来存储一种排列，used存储每次是否已用过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], path = [];</span><br><span class="line">    <span class="title function_">backTrack</span>(nums, nums.<span class="property">length</span>, []);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backTrack</span>(<span class="params">num, len, used</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> == len) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));<span class="comment">//无法直接将path填入res，通过from得到整个path数组而不是path，再将其push</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(num[i]);</span><br><span class="line">            <span class="title function_">backTrack</span>(num, len, used);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221014161723.png"></p>
<p>思路：迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间：O(N)</p>
<p>空间：O(1)</p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221014162452.png"></p>
<p>思路：因为回文数的性质，只需以’i‘为中心判断两种情况</p>
<ol>
<li>‘i’后面有多少个与’i‘相等的值</li>
<li>遇到与‘i’不相等的值时，开始判断‘i’前后成对相等的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        start = i;</span><br><span class="line">        end = i;</span><br><span class="line">        <span class="keyword">while</span> (end + <span class="number">1</span> &lt; s.<span class="property">length</span> &amp;&amp; s[i] == s[end + <span class="number">1</span>]) &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (end + <span class="number">1</span> &lt; s.<span class="property">length</span> &amp;&amp; start - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[start - <span class="number">1</span>] == s[end + <span class="number">1</span>]) &#123;</span><br><span class="line">            end++;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="property">length</span> &lt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">            str = s.<span class="title function_">slice</span>(start, end + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str ? str : s[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221017143201.png"></p>
<p>思路：按层遍历，</p>
<ol>
<li>从左到右遍历上侧元素，依次为 (top,left) 到 (top,right)。</li>
<li>从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。</li>
<li>如果left&lt;right 且 top&lt;bottom，则从右到左遍历下侧元素，依次为 (bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。</li>
<li>每次循环最后都要[left + 1, right - 1, top + 1, bottom - 1]</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix.<span class="property">length</span> || !matrix[<span class="number">0</span>].<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rows = matrix.<span class="property">length</span>, columns = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> order = [];</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> column = left; column &lt;= right; column++) &#123;</span><br><span class="line">            order.<span class="title function_">push</span>(matrix[top][column]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> row = top; row &lt;= bottom; row++) &#123;</span><br><span class="line">            order.<span class="title function_">push</span>(matrix[row][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> column = right - <span class="number">1</span>; column &gt; left; column--) &#123;</span><br><span class="line">                order.<span class="title function_">push</span>(matrix[bottom][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                order.<span class="title function_">push</span>(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [left, right, top, bottom] = [left + <span class="number">1</span>, right - <span class="number">1</span>, top + <span class="number">1</span>, bottom - <span class="number">1</span>];</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221018165315.png"></p>
<p>思路：如果是环形链表快指针总会和慢指针相遇</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> slow = head, fast = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow.<span class="property">next</span> == fast.<span class="property">next</span>.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221018194452.png"></p>
<p>思路：bfs遍历，遇到岛屿1改为0 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numIslands = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span> (x, y) &#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[x-<span class="number">1</span>] &amp;&amp; grid[x-<span class="number">1</span>][y] == <span class="number">1</span>) <span class="title function_">dfs</span>(x - <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (grid[x+<span class="number">1</span>] &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">1</span>) <span class="title function_">dfs</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y-<span class="number">1</span>] &amp;&amp; grid[x][y-<span class="number">1</span>] == <span class="number">1</span>) <span class="title function_">dfs</span>(x, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y+<span class="number">1</span>] &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="title function_">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="title function_">dfs</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221020160520.png"></p>
<p>思路：动态规划；[i]处接到的雨水等于 左右两边最高值 减去 [i]处高度，所以设立两个数组分别得到[i]处的左右两侧最高值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = height.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> leftMax = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        leftMax[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rightMax = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rightMax[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(height[i], rightMax[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans += <span class="title class_">Math</span>.<span class="title function_">min</span>(leftMax[i], rightMax[i]) - height[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221020160953.png"></p>
<p>思路：滑动窗口；每次循环窗口左边界加一，判断是否大于[target]；若大于，则移动窗口右边界，直到[sum]小于[target]，同时记录长度；小于[target]直接进行下一次循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">    <span class="keyword">let</span> start = end = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; end &lt; nums.<span class="property">length</span>; end++) &#123;</span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">min</span>(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans === <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221020225534.png"></p>
<p>思路：dfs；同200题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span> (x, y, count) &#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (grid[x-<span class="number">1</span>] &amp;&amp; grid[x-<span class="number">1</span>][y] == <span class="number">1</span>) <span class="title function_">dfs</span>(x - <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (grid[x+<span class="number">1</span>] &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">1</span>) <span class="title function_">dfs</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y-<span class="number">1</span>] &amp;&amp; grid[x][y-<span class="number">1</span>] == <span class="number">1</span>) <span class="title function_">dfs</span>(x, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y+<span class="number">1</span>] &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">1</span>) <span class="title function_">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> ans = count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">dfs</span>(i, j, count), ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221021152137.png"></p>
<p>思路：动态规划，f(n) &#x3D; f(n - 1) + f(n - 2)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = j = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">        j = k;</span><br><span class="line">        k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="22-剑-链表中倒数第k个节点"><a href="#22-剑-链表中倒数第k个节点" class="headerlink" title="22(剑). 链表中倒数第k个节点"></a>22(剑). 链表中倒数第k个节点</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221021154134.png"></p>
<p>思路：顺序遍历&#x2F;快慢指针，快指针指向第k个，两者同时向后移动，快指针指向null时，慢指针指向倒数第k个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> getKthFromEnd = <span class="keyword">function</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221021154415.png"></p>
<p>思路：回溯；</p>
<ul>
<li>有效条件：左右括号小于[n]，右括号数量小于左括号</li>
<li>添加时两种情况：左or右</li>
<li>递归的终止条件：左右括号数都等于[n]</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backTrack</span>(<span class="params">left, right, str</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == n &amp;&amp; right == n) <span class="keyword">return</span> result.<span class="title function_">push</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            <span class="title function_">backTrack</span>(left + <span class="number">1</span>, right, str + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="title function_">backTrack</span>(left, right + <span class="number">1</span>, str + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">backTrack</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221023165927.png"></p>
<p>思路：递归；从子节点开始翻转</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> left = <span class="title function_">invertTree</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">const</span> right = <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">    root.<span class="property">left</span> = right;</span><br><span class="line">    root.<span class="property">right</span> = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221023170114.png"></p>
<p>思路：用另一个栈存储最小值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">xStack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">30001</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>);<span class="comment">//等同于 this.min = [Infinity]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">xStack</span>.<span class="title function_">push</span>(val);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min</span>.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="property">min</span>[<span class="variable language_">this</span>.<span class="property">min</span>.<span class="property">length</span> - <span class="number">1</span>], val));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">xStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">xStack</span>[<span class="variable language_">this</span>.<span class="property">xStack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">min</span>[<span class="variable language_">this</span>.<span class="property">min</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221023225807.png"></p>
<p>思路：动态规划，amount &#x3D; (amount - coins[]) + 1 &#x2F;&#x2F; 所有种类都试一遍取最小值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="keyword">function</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(amount + <span class="number">1</span>);</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; coins.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                arr[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(arr[i], arr[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> arr[amount] &gt; amount ? -<span class="number">1</span> : arr[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿层序遍历"><a href="#103-二叉树的锯齿层序遍历" class="headerlink" title="103. 二叉树的锯齿层序遍历"></a>103. 二叉树的锯齿层序遍历</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221026204012.png"></p>
<p>思路：dfs（采用层序遍历相同思路）；循环中添加一个状态[isLeft]来确认该层是的遍历顺序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zigzagLevelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> isLeft = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> level = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">                level.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                level.<span class="title function_">unshift</span>(node.<span class="property">val</span>);<span class="comment">//添加到数组首位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="title function_">push</span>(level);</span><br><span class="line">        isLeft = !isLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="718-最长重复子串"><a href="#718-最长重复子串" class="headerlink" title="718. 最长重复子串"></a>718. 最长重复子串</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221026210531.png"></p>
<p>思路：动态规划；  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLength = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = nums1.<span class="property">length</span>, n = nums2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));<span class="comment">//（初始化二维数组全为0）</span></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;<span class="comment">//如果前一位相等，则 该位dp = 前一位dp + 1</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221026211243.png"></p>
<p>思路：动态规划；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化二维数组两边的值为1，防止越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) path[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) path[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            path[i][j] = path[i - <span class="number">1</span>][j] + path[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146. LRU缓存"></a>146. LRU缓存</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221027155019.png"></p>
<p>思路：使用map存储键值对，新存储的键值对会在后面，所以每次将要操作的键值对重新加入map，就可以完成 最少使用使用的放在map的前面，删除时只需删除第一个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">capacity</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> <span class="title class_">LRUCache</span> = <span class="keyword">function</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(key)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(key)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">LRUCache</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, value)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">capacity</span> &lt; <span class="variable language_">this</span>.<span class="property">map</span>.<span class="property">size</span>) &#123;</span><br><span class="line">        <span class="comment">//map.keys 返回所有[key]</span></span><br><span class="line">        <span class="comment">//next() 返回一个对象，&#123;</span></span><br><span class="line">        <span class="comment">// [value]：下一个将要返回的值</span></span><br><span class="line">        <span class="comment">// [done]：是否为最后一个值(布尔型)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="230-二叉搜索树中第k小的元素"><a href="#230-二叉搜索树中第k小的元素" class="headerlink" title="230. 二叉搜索树中第k小的元素"></a>230. 二叉搜索树中第k小的元素</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221027214833.png"></p>
<p>思路：迭代；因为是二叉搜索树，所以 左子树 &lt; 根节点 &lt; 右子树</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthSmallest = <span class="keyword">function</span>(<span class="params">root, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> || !root) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!root) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(root)</span><br><span class="line">            root = root.<span class="property">left</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="title function_">pop</span>()</span><br><span class="line">        --k</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.<span class="property">val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221028163406.png"></p>
<p>思路：递归；对比左右子树</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isMirror = <span class="keyword">function</span> (<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root1 || !root2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.<span class="property">val</span> !== root2.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isMirror</span>(root1.<span class="property">left</span>, root2.<span class="property">right</span>) &amp;&amp; <span class="title function_">isMirror</span>(root1.<span class="property">right</span>, root2.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isMirror</span>(root, root);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221028165037.png"></p>
<p>思路：遇到零时将其删除，同时再数组后面添加；设置[j]保证数组能正常结束循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;<span class="comment">//保证遍历数组到 后面全为0的情况下 仍可以结束循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j++ &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums.<span class="title function_">splice</span>(i, <span class="number">1</span>);<span class="comment">//删除数组[i]处[1]个值</span></span><br><span class="line">                nums.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><img src="https://raw.githubusercontent.com/LVZJself/image/main/20221028171319.png"></p>
<p>思路：dfs</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> lH = <span class="title function_">maxDepth</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> rH = <span class="title function_">maxDepth</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(lH, rH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/07/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="cl95ssihe000194bhhult597h" data-title="算法题记录" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-前端零碎的知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/07/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2022-10-07T15:13:40.000Z" itemprop="datePublished">2022-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/07/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">前端零碎的知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-事件委托"><a href="#1-事件委托" class="headerlink" title="1. 事件委托"></a>1. 事件委托</h2><p>将事件监听器添加到父元素</p>
<p>当触及到子元素时，事件会冒泡到父元素触发监听器</p>
<p>好处：</p>
<ul>
<li>内存占用减少，因为只需一个父元素处理程序</li>
<li>无需 删除时解绑处理程序 或 将处理程序绑定到新元素</li>
</ul>
<h2 id="2-未声明变量-x2F-null-x2F-undefined"><a href="#2-未声明变量-x2F-null-x2F-undefined" class="headerlink" title="2. 未声明变量&#x2F;null&#x2F;undefined"></a>2. 未声明变量&#x2F;null&#x2F;undefined</h2><p><strong>未声明变量</strong>：未使用var、let、const声明变量，就为一个变量赋值</p>
<ul>
<li>全局作用域（严格模式下报错）</li>
</ul>
<p><strong>undefined</strong>：一个变量已经声明但没有赋值</p>
<ul>
<li>使用严格相等（&#x3D;&#x3D;&#x3D;）检查，使用非严格相等（&#x3D;&#x3D;）与null判断时，返回为true</li>
</ul>
<p><strong>null</strong>：只能被显示赋值给变量</p>
<ul>
<li>检查同undefined</li>
</ul>
<h2 id="3-浏览器事件循环-Event-Loop）"><a href="#3-浏览器事件循环-Event-Loop）" class="headerlink" title="3. 浏览器事件循环(Event Loop）"></a>3. 浏览器事件循环(Event Loop）</h2><p>任务分为同步&#x2F;异步</p>
<p>同步进入主线程执行</p>
<p>异步注册回调函数，完成指定任务后进入<code>Event Queue</code>等待主线程完成后执行</p>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082138703.png" style="zoom:50%;" />

<p>注意：<code>promise</code>本身是同步。但是<code>promise</code>的回调<code>then</code>和<code>catch</code>是异步</p>
<p>异步任务分两种：</p>
<ul>
<li><p><code>macro-task</code>(宏任务): </p>
<ul>
<li>整体代码</li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
</ul>
</li>
<li><p><code>micro-task</code>(微任务)：执行于主函数之后，宏任务之前</p>
<ul>
<li><code>Promise</code></li>
<li><code>process.nextTick() //node独有</code></li>
</ul>
</li>
</ul>
<p>宏任务和微任务对应不同的<code>Event Queue</code></p>
<p><strong>顺序</strong>：</p>
<ul>
<li><p>第一次循环：进入整体代码（宏任务）后，接着执行所有微任务</p>
<p>注意：如果在执行<code>microtask</code>的过程中，又产生了<code>microtask</code>，那么会加入到队列的末尾，也会在这个周期</p>
<p>调用执行</p>
</li>
<li><p>第二次循环：再次执行一个宏任务，执行所有微任务</p>
<p>第n次同上</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082139323.png" style="zoom:50%;" />

<p>eg1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​        整体代码作为宏任务开始第一次循环</p>
<ul>
<li><p><strong>输出 1</strong></p>
</li>
<li><p><code>setTimeout</code>的回调函数进入宏任务队列</p>
</li>
<li><p><code>process.nextTick</code>的回调函数排于微队列之前</p>
</li>
<li><p><code>Promise，new Promise</code>直接执行，<strong>输出 7</strong>，<code>then</code>进入微队列</p>
<p>此时第一次宏任务执行完毕，执行所有微任务</p>
</li>
<li><p><code>process.nextTick</code>的回调函数<strong>输出 6</strong></p>
</li>
<li><p><code>then</code><strong>输出 8</strong></p>
<p>第一次<code>Event Loop</code>结束，执行下一个宏任务 <code>setTimeout</code>的回调函数</p>
</li>
<li><p><strong>输出 2</strong></p>
</li>
<li><p><code>process.nextTick</code>的回调函数排于微队列之前</p>
</li>
<li><p><code>Promise，new Promise</code>直接执行，<strong>输出 4</strong>，<code>then</code>进入微队列</p>
<p>此时第二次宏任务执行完毕，执行所有微任务</p>
</li>
<li><p><code>process.nextTick</code>的回调函数<strong>输出 3</strong></p>
</li>
<li><p><code>then</code><strong>输出 5</strong></p>
</li>
</ul>
<p>eg2:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class="line"><span class="comment">// 遇到setTimeout，属于新的宏任务，进入宏任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class="line"><span class="comment">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 console.log(3) 直接打印 3</span></span><br><span class="line"><span class="comment">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class="line"><span class="comment">// 当一次宏任务执行完，并且微任务也清空了, 再去执行新的宏任务，剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure>



<h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h2><p><strong>一个函数访问他的外部变量</strong></p>
<p>调用函数时this指向</p>
<ul>
<li><p>方法调用模式</p>
<p>当一个函数被保存为对象的属性时，称为方法</p>
<p>方法被调用时，this指向 调用者</p>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082212025.png" style="zoom:50%;" />
</li>
<li><p>函数调用模式</p>
<p>指向全局	</p>
<img src="https://raw.githubusercontent.com/LVZJself/image/main/202210082216171.png" style="zoom:80%;" /></li>
</ul>
<p>eg1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="title function_">getNameFunc</span>()());</span><br></pre></td></tr></table></figure>

<p>答案：window</p>
<p>myObject.getNameFunc() 为方法调用，结果为匿名函数 <code>function ()&#123;return this.name;&#125;</code> ，同时 this 指向 myObject</p>
<p>myObject.getNameFunc()() 为函数调用，此时 this 指向全局，所以输出全局变量</p>
<p>eg2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span>;	</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="title function_">getNameFunc</span>()());</span><br></pre></td></tr></table></figure>

<p>答案：object</p>
<p>myObject.getNameFunc() 为方法调用，此时 that 与 this 同时指向 myObject，所以输出局部变量</p>
<h2 id="5-let-x2F-var-x2F-const"><a href="#5-let-x2F-var-x2F-const" class="headerlink" title="5. let&#x2F;var&#x2F;const"></a>5. let&#x2F;var&#x2F;const</h2><ul>
<li><p>var为函数作用域，let&#x2F;const为块级作用域</p>
</li>
<li><p>var可以变量提升</p>
</li>
<li><p>var：可重复声明，值可变</p>
<p>let：同一块级作用域下，let只能声明一次</p>
<p>const：声明时必须赋值，且不允许改变</p>
</li>
<li><p>var在全局作用域声明时会成为windows对象的属性</p>
<p>let不会，但对应变量会在生命周期内存续，访问时为undefined</p>
</li>
</ul>
<h2 id="6-变量-x2F-函数提升"><a href="#6-变量-x2F-函数提升" class="headerlink" title="6. 变量&#x2F;函数提升"></a>6. 变量&#x2F;函数提升</h2><ul>
<li><p>变量提升</p>
<ul>
<li><p>var声明的变量可以提升，值为undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//输出undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码实际执行顺序为</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数提升</p>
<ul>
<li><p>函数声明式：可以在定义前被调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fun</span>();<span class="comment">//输出 函数声明式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数声明式&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式：可以理解为变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun);<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fun);<span class="comment">//undefined</span></span><br><span class="line"><span class="title function_">fun</span>();<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数表达式&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>例题：</p>
<ul>
<li><pre><code class="javascript">function a() &#123;&#125;
var a;
console.log(typeof a)//输出：function，函数因为不会被覆盖
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```javascript</span><br><span class="line">  function a() &#123;&#125;</span><br><span class="line">  var a = 1;</span><br><span class="line">  console.log(typeof a)//输出：number，函数会被覆盖</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;javascript<br>console.log(typeof a)&#x2F;&#x2F;输出：function，因为函数提升优先级高<br>function a() {}<br>var a &#x3D; 1;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    结论：函数提升优先级高于变量提升，且不会被同名变量声明时覆盖；但会被同名变量赋值后覆盖		</span><br><span class="line"></span><br><span class="line">## 7. JS中的arguments</span><br><span class="line"></span><br><span class="line">* 类数组对象，对应于传递给函数的参数 </span><br><span class="line"></span><br><span class="line">* 对应于（除箭头函数）所有函数</span><br><span class="line"></span><br><span class="line">* 可以用如下方式引用</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">arguments[0]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>只有 length 一个属性，对应参数的个数</p>
</li>
<li><p>可以被转换为Array，通过以下方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [].<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);<span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);<span class="comment">//方法2</span></span><br><span class="line"><span class="comment">//ES6新增</span></span><br><span class="line"><span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);<span class="comment">//Array.from可转化类数组和可遍历两种对象</span></span><br><span class="line"><span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>];<span class="comment">// ‘...’ 拓展运算符</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-拓展运算符-…"><a href="#8-拓展运算符-…" class="headerlink" title="8. 拓展运算符 …"></a>8. 拓展运算符 …</h2><p>用于取出参数对象中的所有可遍历属性，(浅)拷贝到当前对象之中</p>
<ul>
<li><p>基础数据类型按值访问，拷贝时复制一份，修改值互不影响</p>
<p>常见的基础数据类型：Number、String、Boolean、Null、Undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1, <span class="attr">b</span>: <span class="string">&#x27;2-edited&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//修改值互不影响</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//  &#123;a: 1, b: &quot;2-edited&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用数据类型拷贝对象的引用</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;d&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1&#125;;</span><br><span class="line">obj2.<span class="property">c</span>.<span class="property">name</span> = <span class="string">&#x27;d-edited&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;a: 1, b: 2, c: &#123;name: &#x27;d-edited&#x27;&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;a: 1, b: 2, c: &#123;name: &#x27;d-edited&#x27;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数组改为参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">add</span>(...numbers) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过解构赋值生成数组（拓展运算符只能放在参数最后一位）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure>
</li>
<li><p>将字符串转化为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-字符串charAt-与"><a href="#9-字符串charAt-与" class="headerlink" title="9. 字符串charAt()与[]"></a>9. 字符串charAt()与[]</h2><ul>
<li><p>都可以获取到字符串对应位置的字符</p>
</li>
<li><p>使用string[index]时，超出index范围会返回 undefined</p>
<p>使用string.charAt(index)时，会返回 空字符串</p>
</li>
<li><p>string[index]：IE6～8 不兼容</p>
<p>string.charAt(index)：IE6～8 兼容</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/07/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cl95ssih7000094bhcfzg9928" data-title="前端零碎的知识点" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/27/bagu/">八股</a>
          </li>
        
          <li>
            <a href="/2022/10/07/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/">算法题记录</a>
          </li>
        
          <li>
            <a href="/2022/10/07/%E5%89%8D%E7%AB%AF%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">前端零碎的知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>